// This file was auto-generated by generator.vsh. Do not edit manually.
module main

import json

pub type IntegerOrString = int | string

pub type InputFileOrString = InputFile | string

pub type InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply = InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply

pub type InputMediaAudioOrInputMediaDocumentOrInputMediaPhotoOrInputMediaVideo = InputMediaAudio | InputMediaDocument | InputMediaPhoto | InputMediaVideo

pub type MessageOrBoolean = Message | bool

// This object contains information about one member of a chat. Currently, the following 6 types of chat members are
// supported:
// - ChatMemberOwner
// - ChatMemberAdministrator
// - ChatMemberMember
// - ChatMemberRestricted
// - ChatMemberLeft
// - ChatMemberBanned
pub type ChatMember = ChatMemberOwner | ChatMemberAdministrator | ChatMemberMember | ChatMemberRestricted | ChatMemberLeft | ChatMemberBanned

// This object represents the scope to which bot commands are applied. Currently, the following 7 scopes are supported:
// - BotCommandScopeDefault
// - BotCommandScopeAllPrivateChats
// - BotCommandScopeAllGroupChats
// - BotCommandScopeAllChatAdministrators
// - BotCommandScopeChat
// - BotCommandScopeChatAdministrators
// - BotCommandScopeChatMember
pub type BotCommandScope = BotCommandScopeDefault | BotCommandScopeAllPrivateChats | BotCommandScopeAllGroupChats | BotCommandScopeAllChatAdministrators | BotCommandScopeChat | BotCommandScopeChatAdministrators | BotCommandScopeChatMember

// This object describes the bot's menu button in a private chat. It should be one of
// - MenuButtonCommands
// - MenuButtonWebApp
// - MenuButtonDefault
// If a menu button other than MenuButtonDefault is set for a private chat, then it is applied in the chat. Otherwise the
// default menu button is applied. By default, the menu button opens the list of bot commands.
pub type MenuButton = MenuButtonCommands | MenuButtonWebApp | MenuButtonDefault

// This object represents the content of a media message to be sent. It should be one of
// - InputMediaAnimation
// - InputMediaDocument
// - InputMediaAudio
// - InputMediaPhoto
// - InputMediaVideo
pub type InputMedia = InputMediaPhoto | InputMediaVideo | InputMediaAnimation | InputMediaAudio | InputMediaDocument

// This object represents one result of an inline query. Telegram clients currently support results of the following 20
// types:
// - InlineQueryResultCachedAudio
// - InlineQueryResultCachedDocument
// - InlineQueryResultCachedGif
// - InlineQueryResultCachedMpeg4Gif
// - InlineQueryResultCachedPhoto
// - InlineQueryResultCachedSticker
// - InlineQueryResultCachedVideo
// - InlineQueryResultCachedVoice
// - InlineQueryResultArticle
// - InlineQueryResultAudio
// - InlineQueryResultContact
// - InlineQueryResultGame
// - InlineQueryResultDocument
// - InlineQueryResultGif
// - InlineQueryResultLocation
// - InlineQueryResultMpeg4Gif
// - InlineQueryResultPhoto
// - InlineQueryResultVenue
// - InlineQueryResultVideo
// - InlineQueryResultVoice
// Note: All URLs passed in inline query results will be available to end users and therefore must be assumed to be
// public.
pub type InlineQueryResult = InlineQueryResultArticle | InlineQueryResultPhoto | InlineQueryResultGif | InlineQueryResultMpeg4Gif | InlineQueryResultVideo | InlineQueryResultAudio | InlineQueryResultVoice | InlineQueryResultDocument | InlineQueryResultLocation | InlineQueryResultVenue | InlineQueryResultContact | InlineQueryResultGame | InlineQueryResultCachedPhoto | InlineQueryResultCachedGif | InlineQueryResultCachedMpeg4Gif | InlineQueryResultCachedSticker | InlineQueryResultCachedDocument | InlineQueryResultCachedVideo | InlineQueryResultCachedVoice | InlineQueryResultCachedAudio

// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently
// support the following 5 types:
// - InputTextMessageContent
// - InputLocationMessageContent
// - InputVenueMessageContent
// - InputContactMessageContent
// - InputInvoiceMessageContent
pub type InputMessageContent = InputTextMessageContent | InputLocationMessageContent | InputVenueMessageContent | InputContactMessageContent | InputInvoiceMessageContent

// This object represents an error in the Telegram Passport element which was submitted that should be resolved by the
// user. It should be one of:
// - PassportElementErrorDataField
// - PassportElementErrorFrontSide
// - PassportElementErrorReverseSide
// - PassportElementErrorSelfie
// - PassportElementErrorFile
// - PassportElementErrorFiles
// - PassportElementErrorTranslationFile
// - PassportElementErrorTranslationFiles
// - PassportElementErrorUnspecified
pub type PassportElementError = PassportElementErrorDataField | PassportElementErrorFrontSide | PassportElementErrorReverseSide | PassportElementErrorSelfie | PassportElementErrorFile | PassportElementErrorFiles | PassportElementErrorTranslationFile | PassportElementErrorTranslationFiles | PassportElementErrorUnspecified

// This object represents an incoming update.
// At most one of the optional parameters can be present in any given update.
pub struct Update {
pub:
    update_id int
    message &Message
    edited_message &Message
    channel_post &Message
    edited_channel_post &Message
    inline_query &InlineQuery
    chosen_inline_result &ChosenInlineResult
    callback_query &CallbackQuery
    shipping_query &ShippingQuery
    pre_checkout_query &PreCheckoutQuery
    poll &Poll
    poll_answer &PollAnswer
    my_chat_member &ChatMemberUpdated
    chat_member &ChatMemberUpdated
    chat_join_request &ChatJoinRequest
}

// Describes the current status of a webhook.
pub struct WebhookInfo {
pub:
    url string
    has_custom_certificate bool
    pending_update_count int
    ip_address string
    last_error_date int
    last_error_message string
    last_synchronization_error_date int
    max_connections int
    allowed_updates []string
}

// This object represents a Telegram user or bot.
pub struct User {
pub:
    id int
    is_bot bool
    first_name string
    last_name string
    username string
    language_code string
    is_premium bool
    added_to_attachment_menu bool
    can_join_groups bool
    can_read_all_group_messages bool
    supports_inline_queries bool
}

// This object represents a chat.
pub struct Chat {
pub:
    id int
    @type string
    title string
    username string
    first_name string
    last_name string
    is_forum bool
    photo &ChatPhoto
    active_usernames []string
    emoji_status_custom_emoji_id string
    bio string
    has_private_forwards bool
    has_restricted_voice_and_video_messages bool
    join_to_send_messages bool
    join_by_request bool
    description string
    invite_link string
    pinned_message &Message
    permissions &ChatPermissions
    slow_mode_delay int
    message_auto_delete_time int
    has_aggressive_anti_spam_enabled bool
    has_hidden_members bool
    has_protected_content bool
    sticker_set_name string
    can_set_sticker_set bool
    linked_chat_id int
    location &ChatLocation
}

// This object represents a message.
pub struct Message {
pub:
    message_id int
    message_thread_id int
    from &User
    sender_chat &Chat
    date int
    chat &Chat
    forward_from &User
    forward_from_chat &Chat
    forward_from_message_id int
    forward_signature string
    forward_sender_name string
    forward_date int
    is_topic_message bool
    is_automatic_forward bool
    reply_to_message &Message
    via_bot &User
    edit_date int
    has_protected_content bool
    media_group_id string
    author_signature string
    text string
    entities []MessageEntity
    animation &Animation
    audio &Audio
    document &Document
    photo []PhotoSize
    sticker &Sticker
    video &Video
    video_note &VideoNote
    voice &Voice
    caption string
    caption_entities []MessageEntity
    has_media_spoiler bool
    contact &Contact
    dice &Dice
    game &Game
    poll &Poll
    venue &Venue
    location &Location
    new_chat_members []User
    left_chat_member &User
    new_chat_title string
    new_chat_photo []PhotoSize
    delete_chat_photo bool
    group_chat_created bool
    supergroup_chat_created bool
    channel_chat_created bool
    message_auto_delete_timer_changed &MessageAutoDeleteTimerChanged
    migrate_to_chat_id int
    migrate_from_chat_id int
    pinned_message &Message
    invoice &Invoice
    successful_payment &SuccessfulPayment
    user_shared &UserShared
    chat_shared &ChatShared
    connected_website string
    write_access_allowed &WriteAccessAllowed
    passport_data &PassportData
    proximity_alert_triggered &ProximityAlertTriggered
    forum_topic_created &ForumTopicCreated
    forum_topic_edited &ForumTopicEdited
    forum_topic_closed &ForumTopicClosed
    forum_topic_reopened &ForumTopicReopened
    general_forum_topic_hidden &GeneralForumTopicHidden
    general_forum_topic_unhidden &GeneralForumTopicUnhidden
    video_chat_scheduled &VideoChatScheduled
    video_chat_started &VideoChatStarted
    video_chat_ended &VideoChatEnded
    video_chat_participants_invited &VideoChatParticipantsInvited
    web_app_data &WebAppData
    reply_markup &InlineKeyboardMarkup
}

// This object represents a unique message identifier.
pub struct MessageId {
pub:
    message_id int
}

// This object represents one special entity in a text message. For example, hashtags, usernames, URLs, etc.
pub struct MessageEntity {
pub:
    @type string
    offset int
    length int
    url string
    user &User
    language string
    custom_emoji_id string
}

// This object represents one size of a photo or a file / sticker thumbnail.
pub struct PhotoSize {
pub:
    file_id string
    file_unique_id string
    width int
    height int
    file_size int
}

// This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
pub struct Animation {
pub:
    file_id string
    file_unique_id string
    width int
    height int
    duration int
    thumbnail &PhotoSize
    file_name string
    mime_type string
    file_size int
}

// This object represents an audio file to be treated as music by the Telegram clients.
pub struct Audio {
pub:
    file_id string
    file_unique_id string
    duration int
    performer string
    title string
    file_name string
    mime_type string
    file_size int
    thumbnail &PhotoSize
}

// This object represents a general file (as opposed to photos, voice messages and audio files).
pub struct Document {
pub:
    file_id string
    file_unique_id string
    thumbnail &PhotoSize
    file_name string
    mime_type string
    file_size int
}

// This object represents a video file.
pub struct Video {
pub:
    file_id string
    file_unique_id string
    width int
    height int
    duration int
    thumbnail &PhotoSize
    file_name string
    mime_type string
    file_size int
}

// This object represents a video message (available in Telegram apps as of v.4.0).
pub struct VideoNote {
pub:
    file_id string
    file_unique_id string
    length int
    duration int
    thumbnail &PhotoSize
    file_size int
}

// This object represents a voice note.
pub struct Voice {
pub:
    file_id string
    file_unique_id string
    duration int
    mime_type string
    file_size int
}

// This object represents a phone contact.
pub struct Contact {
pub:
    phone_number string
    first_name string
    last_name string
    user_id int
    vcard string
}

// This object represents an animated emoji that displays a random value.
pub struct Dice {
pub:
    emoji string
    value int
}

// This object contains information about one answer option in a poll.
pub struct PollOption {
pub:
    text string
    voter_count int
}

// This object represents an answer of a user in a non-anonymous poll.
pub struct PollAnswer {
pub:
    poll_id string
    user &User
    option_ids []int
}

// This object contains information about a poll.
pub struct Poll {
pub:
    id string
    question string
    options []PollOption
    total_voter_count int
    is_closed bool
    is_anonymous bool
    @type string
    allows_multiple_answers bool
    correct_option_id int
    explanation string
    explanation_entities []MessageEntity
    open_period int
    close_date int
}

// This object represents a point on the map.
pub struct Location {
pub:
    longitude f64
    latitude f64
    horizontal_accuracy f64
    live_period int
    heading int
    proximity_alert_radius int
}

// This object represents a venue.
pub struct Venue {
pub:
    location &Location
    title string
    address string
    foursquare_id string
    foursquare_type string
    google_place_id string
    google_place_type string
}

// Describes data sent from a Web App to the bot.
pub struct WebAppData {
pub:
    data string
    button_text string
}

// This object represents the content of a service message, sent whenever a user in the chat triggers a proximity alert
// set by another user.
pub struct ProximityAlertTriggered {
pub:
    traveler &User
    watcher &User
    distance int
}

// This object represents a service message about a change in auto-delete timer settings.
pub struct MessageAutoDeleteTimerChanged {
pub:
    message_auto_delete_time int
}

// This object represents a service message about a new forum topic created in the chat.
pub struct ForumTopicCreated {
pub:
    name string
    icon_color int
    icon_custom_emoji_id string
}

// This object represents a service message about a forum topic closed in the chat. Currently holds no information.
pub struct ForumTopicClosed {}

// This object represents a service message about an edited forum topic.
pub struct ForumTopicEdited {
pub:
    name string
    icon_custom_emoji_id string
}

// This object represents a service message about a forum topic reopened in the chat. Currently holds no information.
pub struct ForumTopicReopened {}

// This object represents a service message about General forum topic hidden in the chat. Currently holds no information.
pub struct GeneralForumTopicHidden {}

// This object represents a service message about General forum topic unhidden in the chat. Currently holds no
// information.
pub struct GeneralForumTopicUnhidden {}

// This object contains information about the user whose identifier was shared with the bot using a
// KeyboardButtonRequestUser button.
pub struct UserShared {
pub:
    request_id int
    user_id int
}

// This object contains information about the chat whose identifier was shared with the bot using a
// KeyboardButtonRequestChat button.
pub struct ChatShared {
pub:
    request_id int
    chat_id int
}

// This object represents a service message about a user allowing a bot to write messages after adding the bot to the
// attachment menu or launching a Web App from a link.
pub struct WriteAccessAllowed {
pub:
    web_app_name string
}

// This object represents a service message about a video chat scheduled in the chat.
pub struct VideoChatScheduled {
pub:
    start_date int
}

// This object represents a service message about a video chat started in the chat. Currently holds no information.
pub struct VideoChatStarted {}

// This object represents a service message about a video chat ended in the chat.
pub struct VideoChatEnded {
pub:
    duration int
}

// This object represents a service message about new members invited to a video chat.
pub struct VideoChatParticipantsInvited {
pub:
    users []User
}

// This object represent a user's profile pictures.
pub struct UserProfilePhotos {
pub:
    total_count int
    photos [][]PhotoSize
}

// This object represents a file ready to be downloaded. The file can be downloaded via the link
// https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be
// valid for at least 1 hour. When the link expires, a new one can be requested by calling
// getFile.
pub struct File {
pub:
    file_id string
    file_unique_id string
    file_size int
    file_path string
}

// Describes a Web App.
pub struct WebAppInfo {
pub:
    url string
}

// This object represents a custom keyboard with reply options (see Introduction to bots for details and examples).
pub struct ReplyKeyboardMarkup {
pub:
    keyboard [][]KeyboardButton
    is_persistent bool
    resize_keyboard bool
    one_time_keyboard bool
    input_field_placeholder string
    selective bool
}

// This object represents one button of the reply keyboard. For simple text buttons, String can be used instead of this
// object to specify the button text. The optional fields web_app, request_user, request_chat, request_contact,
// request_location, and request_poll are mutually exclusive.
// Note: request_contact and request_location options will only work in Telegram versions released after 9 April, 2016.
// Older clients will display unsupported message.
// Note: request_poll option will only work in Telegram versions released after 23 January, 2020. Older clients will
// display unsupported message.
// Note: web_app option will only work in Telegram versions released after 16 April, 2022. Older clients will display
// unsupported message.
// Note: request_user and request_chat options will only work in Telegram versions released after 3 February, 2023. Older
// clients will display unsupported message.
pub struct KeyboardButton {
pub:
    text string
    request_user &KeyboardButtonRequestUser
    request_chat &KeyboardButtonRequestChat
    request_contact bool
    request_location bool
    request_poll &KeyboardButtonPollType
    web_app &WebAppInfo
}

// This object defines the criteria used to request a suitable user. The identifier of the selected user will be shared
// with the bot when the corresponding button is pressed. More about requesting users:
// https://core.telegram.org/bots/features#chat-and-user-selection
pub struct KeyboardButtonRequestUser {
pub:
    request_id int
    user_is_bot bool
    user_is_premium bool
}

// This object defines the criteria used to request a suitable chat. The identifier of the selected chat will be shared
// with the bot when the corresponding button is pressed. More about requesting chats:
// https://core.telegram.org/bots/features#chat-and-user-selection
pub struct KeyboardButtonRequestChat {
pub:
    request_id int
    chat_is_channel bool
    chat_is_forum bool
    chat_has_username bool
    chat_is_created bool
    user_administrator_rights &ChatAdministratorRights
    bot_administrator_rights &ChatAdministratorRights
    bot_is_member bool
}

// This object represents type of a poll, which is allowed to be created and sent when the corresponding button is
// pressed.
pub struct KeyboardButtonPollType {
pub:
    @type string
}

// Upon receiving a message with this object, Telegram clients will remove the current custom keyboard and display the
// default letter-keyboard. By default, custom keyboards are displayed until a new keyboard is sent by a bot. An
// exception is made for one-time keyboards that are hidden immediately after the user presses a button (see
// ReplyKeyboardMarkup).
pub struct ReplyKeyboardRemove {
pub:
    remove_keyboard bool
    selective bool
}

// This object represents an inline keyboard that appears right next to the message it belongs to.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported
// message.
pub struct InlineKeyboardMarkup {
pub:
    inline_keyboard [][]InlineKeyboardButton
}

// This object represents one button of an inline keyboard. You must use exactly one of the optional fields.
pub struct InlineKeyboardButton {
pub:
    text string
    url string
    callback_data string
    web_app &WebAppInfo
    login_url &LoginUrl
    switch_inline_query string
    switch_inline_query_current_chat string
    switch_inline_query_chosen_chat &SwitchInlineQueryChosenChat
    callback_game &CallbackGame
    pay bool
}

// This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a
// great replacement for the Telegram Login Widget when the user is coming from Telegram. All the user needs to do is
// tap/click a button and confirm that they want to log in:
// Telegram apps support these buttons as of version 5.7.
pub struct LoginUrl {
pub:
    url string
    forward_text string
    bot_username string
    request_write_access bool
}

// This object represents an inline button that switches the current user to inline mode in a chosen chat, with an
// optional default inline query.
pub struct SwitchInlineQueryChosenChat {
pub:
    query string
    allow_user_chats bool
    allow_bot_chats bool
    allow_group_chats bool
    allow_channel_chats bool
}

// This object represents an incoming callback query from a callback button in an inline keyboard. If the button that
// originated the query was attached to a message sent by the bot, the field message will be present. If the button
// was attached to a message sent via the bot (in inline mode), the field inline_message_id will be present.
// Exactly one of the fields data or game_short_name will be present.
pub struct CallbackQuery {
pub:
    id string
    from &User
    message &Message
    inline_message_id string
    chat_instance string
    data string
    game_short_name string
}

// Upon receiving a message with this object, Telegram clients will display a reply interface to the user (act as if the
// user has selected the bot's message and tapped 'Reply'). This can be extremely useful if you want to create
// user-friendly step-by-step interfaces without having to sacrifice privacy mode.
pub struct ForceReply {
pub:
    force_reply bool
    input_field_placeholder string
    selective bool
}

// This object represents a chat photo.
pub struct ChatPhoto {
pub:
    small_file_id string
    small_file_unique_id string
    big_file_id string
    big_file_unique_id string
}

// Represents an invite link for a chat.
pub struct ChatInviteLink {
pub:
    invite_link string
    creator &User
    creates_join_request bool
    is_primary bool
    is_revoked bool
    name string
    expire_date int
    member_limit int
    pending_join_request_count int
}

// Represents the rights of an administrator in a chat.
pub struct ChatAdministratorRights {
pub:
    is_anonymous bool
    can_manage_chat bool
    can_delete_messages bool
    can_manage_video_chats bool
    can_restrict_members bool
    can_promote_members bool
    can_change_info bool
    can_invite_users bool
    can_post_messages bool
    can_edit_messages bool
    can_pin_messages bool
    can_manage_topics bool
}

// Represents a chat member that owns the chat and has all administrator privileges.
pub struct ChatMemberOwner {
pub:
    status string
    user &User
    is_anonymous bool
    custom_title string
}

// Represents a chat member that has some additional privileges.
pub struct ChatMemberAdministrator {
pub:
    status string
    user &User
    can_be_edited bool
    is_anonymous bool
    can_manage_chat bool
    can_delete_messages bool
    can_manage_video_chats bool
    can_restrict_members bool
    can_promote_members bool
    can_change_info bool
    can_invite_users bool
    can_post_messages bool
    can_edit_messages bool
    can_pin_messages bool
    can_manage_topics bool
    custom_title string
}

// Represents a chat member that has no additional privileges or restrictions.
pub struct ChatMemberMember {
pub:
    status string
    user &User
}

// Represents a chat member that is under certain restrictions in the chat. Supergroups only.
pub struct ChatMemberRestricted {
pub:
    status string
    user &User
    is_member bool
    can_send_messages bool
    can_send_audios bool
    can_send_documents bool
    can_send_photos bool
    can_send_videos bool
    can_send_video_notes bool
    can_send_voice_notes bool
    can_send_polls bool
    can_send_other_messages bool
    can_add_web_page_previews bool
    can_change_info bool
    can_invite_users bool
    can_pin_messages bool
    can_manage_topics bool
    until_date int
}

// Represents a chat member that isn't currently a member of the chat, but may join it themselves.
pub struct ChatMemberLeft {
pub:
    status string
    user &User
}

// Represents a chat member that was banned in the chat and can't return to the chat or view chat messages.
pub struct ChatMemberBanned {
pub:
    status string
    user &User
    until_date int
}

// This object represents changes in the status of a chat member.
pub struct ChatMemberUpdated {
pub:
    chat &Chat
    from &User
    date int
    old_chat_member &ChatMember
    new_chat_member &ChatMember
    invite_link &ChatInviteLink
    via_chat_folder_invite_link bool
}

// Represents a join request sent to a chat.
pub struct ChatJoinRequest {
pub:
    chat &Chat
    from &User
    user_chat_id int
    date int
    bio string
    invite_link &ChatInviteLink
}

// Describes actions that a non-administrator user is allowed to take in a chat.
pub struct ChatPermissions {
pub:
    can_send_messages bool
    can_send_audios bool
    can_send_documents bool
    can_send_photos bool
    can_send_videos bool
    can_send_video_notes bool
    can_send_voice_notes bool
    can_send_polls bool
    can_send_other_messages bool
    can_add_web_page_previews bool
    can_change_info bool
    can_invite_users bool
    can_pin_messages bool
    can_manage_topics bool
}

// Represents a location to which a chat is connected.
pub struct ChatLocation {
pub:
    location &Location
    address string
}

// This object represents a forum topic.
pub struct ForumTopic {
pub:
    message_thread_id int
    name string
    icon_color int
    icon_custom_emoji_id string
}

// This object represents a bot command.
pub struct BotCommand {
pub:
    command string
    description string
}

// Represents the default scope of bot commands. Default commands are used if no commands with a narrower scope are
// specified for the user.
pub struct BotCommandScopeDefault {
pub:
    @type string
}

// Represents the scope of bot commands, covering all private chats.
pub struct BotCommandScopeAllPrivateChats {
pub:
    @type string
}

// Represents the scope of bot commands, covering all group and supergroup chats.
pub struct BotCommandScopeAllGroupChats {
pub:
    @type string
}

// Represents the scope of bot commands, covering all group and supergroup chat administrators.
pub struct BotCommandScopeAllChatAdministrators {
pub:
    @type string
}

// Represents the scope of bot commands, covering a specific chat.
pub struct BotCommandScopeChat {
pub:
    @type string
    chat_id &IntegerOrString
}

// Represents the scope of bot commands, covering all administrators of a specific group or supergroup chat.
pub struct BotCommandScopeChatAdministrators {
pub:
    @type string
    chat_id &IntegerOrString
}

// Represents the scope of bot commands, covering a specific member of a group or supergroup chat.
pub struct BotCommandScopeChatMember {
pub:
    @type string
    chat_id &IntegerOrString
    user_id int
}

// This object represents the bot's name.
pub struct BotName {
pub:
    name string
}

// This object represents the bot's description.
pub struct BotDescription {
pub:
    description string
}

// This object represents the bot's short description.
pub struct BotShortDescription {
pub:
    short_description string
}

// Represents a menu button, which opens the bot's list of commands.
pub struct MenuButtonCommands {
pub:
    @type string
}

// Represents a menu button, which launches a Web App.
pub struct MenuButtonWebApp {
pub:
    @type string
    text string
    web_app &WebAppInfo
}

// Describes that no specific value for the menu button was set.
pub struct MenuButtonDefault {
pub:
    @type string
}

// Describes why a request was unsuccessful.
pub struct ResponseParameters {
pub:
    migrate_to_chat_id int
    retry_after int
}

// Represents a photo to be sent.
pub struct InputMediaPhoto {
pub:
    @type string = 'photo'
    media string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    has_spoiler bool
}

// Represents a video to be sent.
pub struct InputMediaVideo {
pub:
    @type string = 'video'
    media string
    thumbnail &InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    width int
    height int
    duration int
    supports_streaming bool
    has_spoiler bool
}

// Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent.
pub struct InputMediaAnimation {
pub:
    @type string = 'animation'
    media string
    thumbnail &InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    width int
    height int
    duration int
    has_spoiler bool
}

// Represents an audio file to be treated as music to be sent.
pub struct InputMediaAudio {
pub:
    @type string = 'audio'
    media string
    thumbnail &InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    duration int
    performer string
    title string
}

// Represents a general file to be sent.
pub struct InputMediaDocument {
pub:
    @type string = 'document'
    media string
    thumbnail &InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    disable_content_type_detection bool
}

// This object represents a sticker.
pub struct Sticker {
pub:
    file_id string
    file_unique_id string
    @type string
    width int
    height int
    is_animated bool
    is_video bool
    thumbnail &PhotoSize
    emoji string
    set_name string
    premium_animation &File
    mask_position &MaskPosition
    custom_emoji_id string
    needs_repainting bool
    file_size int
}

// This object represents a sticker set.
pub struct StickerSet {
pub:
    name string
    title string
    sticker_type string
    is_animated bool
    is_video bool
    stickers []Sticker
    thumbnail &PhotoSize
}

// This object describes the position on faces where a mask should be placed by default.
pub struct MaskPosition {
pub:
    point string
    x_shift f64
    y_shift f64
    scale f64
}

// This object describes a sticker to be added to a sticker set.
pub struct InputSticker {
pub:
    sticker &InputFileOrString
    emoji_list []string
    mask_position &MaskPosition
    keywords []string
}

// This object represents an incoming inline query. When the user sends an empty query, your bot could return some default
// or trending results.
pub struct InlineQuery {
pub:
    id string
    from &User
    query string
    offset string
    chat_type string
    location &Location
}

// This object represents a button to be shown above inline query results. You must use exactly one of the optional
// fields.
pub struct InlineQueryResultsButton {
pub:
    text string
    web_app &WebAppInfo
    start_parameter string
}

// Represents a link to an article or web page.
pub struct InlineQueryResultArticle {
pub:
    @type string = 'article'
    id string
    title string
    input_message_content &InputMessageContent
    reply_markup &InlineKeyboardMarkup
    url string
    hide_url bool
    description string
    thumbnail_url string
    thumbnail_width int
    thumbnail_height int
}

// Represents a link to a photo. By default, this photo will be sent by the user with optional caption. Alternatively, you
// can use input_message_content to send a message with the specified content instead of the photo.
pub struct InlineQueryResultPhoto {
pub:
    @type string = 'photo'
    id string
    photo_url string
    thumbnail_url string
    photo_width int
    photo_height int
    title string
    description string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to an animated GIF file. By default, this animated GIF file will be sent by the user with optional
// caption. Alternatively, you can use input_message_content to send a message with the specified content instead of
// the animation.
pub struct InlineQueryResultGif {
pub:
    @type string = 'gif'
    id string
    gif_url string
    gif_width int
    gif_height int
    gif_duration int
    thumbnail_url string
    thumbnail_mime_type string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this animated MPEG-4 file
// will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message
// with the specified content instead of the animation.
pub struct InlineQueryResultMpeg4Gif {
pub:
    @type string = 'mpeg4_gif'
    id string
    mpeg4_url string
    mpeg4_width int
    mpeg4_height int
    mpeg4_duration int
    thumbnail_url string
    thumbnail_mime_type string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to a page containing an embedded video player or a video file. By default, this video file will be
// sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with
// the specified content instead of the video.
pub struct InlineQueryResultVideo {
pub:
    @type string = 'video'
    id string
    video_url string
    mime_type string
    thumbnail_url string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    video_width int
    video_height int
    video_duration int
    description string
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to an MP3 audio file. By default, this audio file will be sent by the user. Alternatively, you can
// use input_message_content to send a message with the specified content instead of the audio.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultAudio {
pub:
    @type string = 'audio'
    id string
    audio_url string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    performer string
    audio_duration int
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to a voice recording in an .OGG container encoded with OPUS. By default, this voice recording will be
// sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead
// of the the voice message.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultVoice {
pub:
    @type string = 'voice'
    id string
    voice_url string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    voice_duration int
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to a file. By default, this file will be sent by the user with an optional caption. Alternatively,
// you can use input_message_content to send a message with the specified content instead of the file. Currently, only
// .PDF and .ZIP files can be sent using this method.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultDocument {
pub:
    @type string = 'document'
    id string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    document_url string
    mime_type string
    description string
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
    thumbnail_url string
    thumbnail_width int
    thumbnail_height int
}

// Represents a location on a map. By default, the location will be sent by the user. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the location.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultLocation {
pub:
    @type string = 'location'
    id string
    latitude f64
    longitude f64
    title string
    horizontal_accuracy f64
    live_period int
    heading int
    proximity_alert_radius int
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
    thumbnail_url string
    thumbnail_width int
    thumbnail_height int
}

// Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use input_message_content to
// send a message with the specified content instead of the venue.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultVenue {
pub:
    @type string = 'venue'
    id string
    latitude f64
    longitude f64
    title string
    address string
    foursquare_id string
    foursquare_type string
    google_place_id string
    google_place_type string
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
    thumbnail_url string
    thumbnail_width int
    thumbnail_height int
}

// Represents a contact with a phone number. By default, this contact will be sent by the user. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the contact.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultContact {
pub:
    @type string = 'contact'
    id string
    phone_number string
    first_name string
    last_name string
    vcard string
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
    thumbnail_url string
    thumbnail_width int
    thumbnail_height int
}

// Represents a Game.
// Note: This will only work in Telegram versions released after October 1, 2016. Older clients will not display any
// inline results if a game result is among them.
pub struct InlineQueryResultGame {
pub:
    @type string = 'game'
    id string
    game_short_name string
    reply_markup &InlineKeyboardMarkup
}

// Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent by the user with an
// optional caption. Alternatively, you can use input_message_content to send a message with the specified content
// instead of the photo.
pub struct InlineQueryResultCachedPhoto {
pub:
    @type string = 'photo'
    id string
    photo_file_id string
    title string
    description string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to an animated GIF file stored on the Telegram servers. By default, this animated GIF file will be
// sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with
// specified content instead of the animation.
pub struct InlineQueryResultCachedGif {
pub:
    @type string = 'gif'
    id string
    gif_file_id string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the Telegram servers. By
// default, this animated MPEG-4 file will be sent by the user with an optional caption. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the animation.
pub struct InlineQueryResultCachedMpeg4Gif {
pub:
    @type string = 'mpeg4_gif'
    id string
    mpeg4_file_id string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be sent by the user.
// Alternatively, you can use input_message_content to send a message with the specified content instead of the
// sticker.
// Note: This will only work in Telegram versions released after 9 April, 2016 for static stickers and after 06 July, 2019
// for animated stickers. Older clients will ignore them.
pub struct InlineQueryResultCachedSticker {
pub:
    @type string = 'sticker'
    id string
    sticker_file_id string
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to a file stored on the Telegram servers. By default, this file will be sent by the user with an
// optional caption. Alternatively, you can use input_message_content to send a message with the specified content
// instead of the file.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultCachedDocument {
pub:
    @type string = 'document'
    id string
    title string
    document_file_id string
    description string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to a video file stored on the Telegram servers. By default, this video file will be sent by the user
// with an optional caption. Alternatively, you can use input_message_content to send a message with the specified
// content instead of the video.
pub struct InlineQueryResultCachedVideo {
pub:
    @type string = 'video'
    id string
    video_file_id string
    title string
    description string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to a voice message stored on the Telegram servers. By default, this voice message will be sent by the
// user. Alternatively, you can use input_message_content to send a message with the specified content instead of the
// voice message.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultCachedVoice {
pub:
    @type string = 'voice'
    id string
    voice_file_id string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents a link to an MP3 audio file stored on the Telegram servers. By default, this audio file will be sent by the
// user. Alternatively, you can use input_message_content to send a message with the specified content instead of the
// audio.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultCachedAudio {
pub:
    @type string = 'audio'
    id string
    audio_file_id string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup &InlineKeyboardMarkup
    input_message_content &InputMessageContent
}

// Represents the content of a text message to be sent as the result of an inline query.
pub struct InputTextMessageContent {
pub:
    message_text string
    parse_mode string
    entities []MessageEntity
    disable_web_page_preview bool
}

// Represents the content of a location message to be sent as the result of an inline query.
pub struct InputLocationMessageContent {
pub:
    latitude f64
    longitude f64
    horizontal_accuracy f64
    live_period int
    heading int
    proximity_alert_radius int
}

// Represents the content of a venue message to be sent as the result of an inline query.
pub struct InputVenueMessageContent {
pub:
    latitude f64
    longitude f64
    title string
    address string
    foursquare_id string
    foursquare_type string
    google_place_id string
    google_place_type string
}

// Represents the content of a contact message to be sent as the result of an inline query.
pub struct InputContactMessageContent {
pub:
    phone_number string
    first_name string
    last_name string
    vcard string
}

// Represents the content of an invoice message to be sent as the result of an inline query.
pub struct InputInvoiceMessageContent {
pub:
    title string
    description string
    payload string
    provider_token string
    currency string
    prices []LabeledPrice
    max_tip_amount int
    suggested_tip_amounts []int
    provider_data string
    photo_url string
    photo_size int
    photo_width int
    photo_height int
    need_name bool
    need_phone_number bool
    need_email bool
    need_shipping_address bool
    send_phone_number_to_provider bool
    send_email_to_provider bool
    is_flexible bool
}

// Represents a result of an inline query that was chosen by the user and sent to their chat partner.
// Note: It is necessary to enable inline feedback via @BotFather in order to receive these objects in updates.
pub struct ChosenInlineResult {
pub:
    result_id string
    from &User
    location &Location
    inline_message_id string
    query string
}

// Describes an inline message sent by a Web App on behalf of a user.
pub struct SentWebAppMessage {
pub:
    inline_message_id string
}

// This object represents a portion of the price for goods or services.
pub struct LabeledPrice {
pub:
    label string
    amount int
}

// This object contains basic information about an invoice.
pub struct Invoice {
pub:
    title string
    description string
    start_parameter string
    currency string
    total_amount int
}

// This object represents a shipping address.
pub struct ShippingAddress {
pub:
    country_code string
    state string
    city string
    street_line1 string
    street_line2 string
    post_code string
}

// This object represents information about an order.
pub struct OrderInfo {
pub:
    name string
    phone_number string
    email string
    shipping_address &ShippingAddress
}

// This object represents one shipping option.
pub struct ShippingOption {
pub:
    id string
    title string
    prices []LabeledPrice
}

// This object contains basic information about a successful payment.
pub struct SuccessfulPayment {
pub:
    currency string
    total_amount int
    invoice_payload string
    shipping_option_id string
    order_info &OrderInfo
    telegram_payment_charge_id string
    provider_payment_charge_id string
}

// This object contains information about an incoming shipping query.
pub struct ShippingQuery {
pub:
    id string
    from &User
    invoice_payload string
    shipping_address &ShippingAddress
}

// This object contains information about an incoming pre-checkout query.
pub struct PreCheckoutQuery {
pub:
    id string
    from &User
    currency string
    total_amount int
    invoice_payload string
    shipping_option_id string
    order_info &OrderInfo
}

// Describes Telegram Passport data shared with the bot by the user.
pub struct PassportData {
pub:
    data []EncryptedPassportElement
    credentials &EncryptedCredentials
}

// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format
// when decrypted and don't exceed 10MB.
pub struct PassportFile {
pub:
    file_id string
    file_unique_id string
    file_size int
    file_date int
}

// Describes documents or other Telegram Passport elements shared with the bot by the user.
pub struct EncryptedPassportElement {
pub:
    @type string
    data string
    phone_number string
    email string
    files []PassportFile
    front_side &PassportFile
    reverse_side &PassportFile
    selfie &PassportFile
    translation []PassportFile
    hash string
}

// Describes data required for decrypting and authenticating EncryptedPassportElement. See the Telegram Passport
// Documentation for a complete description of the data decryption and authentication processes.
pub struct EncryptedCredentials {
pub:
    data string
    hash string
    secret string
}

// Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the
// field's value changes.
pub struct PassportElementErrorDataField {
pub:
    source string
    @type string
    field_name string
    data_hash string
    message string
}

// Represents an issue with the front side of a document. The error is considered resolved when the file with the front
// side of the document changes.
pub struct PassportElementErrorFrontSide {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse
// side of the document changes.
pub struct PassportElementErrorReverseSide {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie
// changes.
pub struct PassportElementErrorSelfie {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with a document scan. The error is considered resolved when the file with the document scan
// changes.
pub struct PassportElementErrorFile {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans
// changes.
pub struct PassportElementErrorFiles {
pub:
    source string
    @type string
    file_hashes []string
    message string
}

// Represents an issue with one of the files that constitute the translation of a document. The error is considered
// resolved when the file changes.
pub struct PassportElementErrorTranslationFile {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with the translated version of a document. The error is considered resolved when a file with the
// document translation change.
pub struct PassportElementErrorTranslationFiles {
pub:
    source string
    @type string
    file_hashes []string
    message string
}

// Represents an issue in an unspecified place. The error is considered resolved when new data is added.
pub struct PassportElementErrorUnspecified {
pub:
    source string
    @type string
    element_hash string
    message string
}

// This object represents a game. Use BotFather to create and edit games, their short names will act as unique
// identifiers.
pub struct Game {
pub:
    title string
    description string
    photo []PhotoSize
    text string
    text_entities []MessageEntity
    animation &Animation
}

// A placeholder, currently holds no information. Use BotFather to set up your game.
pub struct CallbackGame {}

// This object represents one row of the high scores table for a game.
pub struct GameHighScore {
pub:
    position int
    user &User
    score int
}

// Params for the `get_updates` function.
pub struct GetUpdatesParams {
pub mut:
    offset int
    limit int
    timeout int
    allowed_updates []string
}

// Use this method to receive incoming updates using long polling (wiki). Returns an Array of Update objects.
pub fn (ctx Context) get_updates(params GetUpdatesParams) ![]Update {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getUpdates", body)!
    res := json.decode(ApiResponse[[]Update], raw_json)!
    return res.result
}

// Params for the `set_webhook` function.
pub struct SetWebhookParams {
pub mut:
    url string [required]
    certificate InputFile
    ip_address string
    max_connections int
    allowed_updates []string
    drop_pending_updates bool
    secret_token string
}

// Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever there is an update for
// the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized Update. In case of an
// unsuccessful request, we will give up after a reasonable amount of attempts. Returns True on success.
// If you'd like to make sure that the webhook was set by you, you can specify secret data in the parameter secret_token.
// If specified, the request will contain a header "X-Telegram-Bot-Api-Secret-Token" with the secret token as content.
pub fn (ctx Context) set_webhook(params SetWebhookParams) !bool {
    mut raw_json := ctx.request_multipart("setWebhook", params)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_webhook` function.
pub struct DeleteWebhookParams {
pub mut:
    drop_pending_updates bool
}

// Use this method to remove webhook integration if you decide to switch back to getUpdates. Returns True on success.
pub fn (ctx Context) delete_webhook(params DeleteWebhookParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteWebhook", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Use this method to get current webhook status. Requires no parameters. On success, returns a WebhookInfo object. If the
// bot is using getUpdates, will return an object with the url field empty.
pub fn (ctx Context) get_webhook_info() !WebhookInfo {
    mut body := "{}"
    mut raw_json := ctx.request("getWebhookInfo", body)!
    res := json.decode(ApiResponse[WebhookInfo], raw_json)!
    return res.result
}

// A simple method for testing your bot's authentication token. Requires no parameters. Returns basic information about
// the bot in form of a User object.
pub fn (ctx Context) get_me() !User {
    mut body := "{}"
    mut raw_json := ctx.request("getMe", body)!
    res := json.decode(ApiResponse[User], raw_json)!
    return res.result
}

// Use this method to log out from the cloud Bot API server before launching the bot locally. You must log out the bot
// before running it locally, otherwise there is no guarantee that the bot will receive updates. After a successful
// call, you can immediately log in on a local server, but will not be able to log in back to the cloud Bot API
// server for 10 minutes. Returns True on success. Requires no parameters.
pub fn (ctx Context) log_out() !bool {
    mut body := "{}"
    mut raw_json := ctx.request("logOut", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Use this method to close the bot instance before moving it from one local server to another. You need to delete the
// webhook before calling this method to ensure that the bot isn't launched again after server restart. The method
// will return error 429 in the first 10 minutes after the bot is launched. Returns True on success. Requires no
// parameters.
pub fn (ctx Context) close() !bool {
    mut body := "{}"
    mut raw_json := ctx.request("close", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `send_message` function.
pub struct SendMessageParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    text string [required]
    parse_mode string
    entities []MessageEntity
    disable_web_page_preview bool
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send text messages. On success, the sent Message is returned.
pub fn (ctx Context) send_message(params SendMessageParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendMessage", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `forward_message` function.
pub struct ForwardMessageParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    from_chat_id IntegerOrString [required]
    disable_notification bool
    protect_content bool
    message_id int [required]
}

// Use this method to forward messages of any kind. Service messages can't be forwarded. On success, the sent Message is
// returned.
pub fn (ctx Context) forward_message(params ForwardMessageParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("forwardMessage", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `copy_message` function.
pub struct CopyMessageParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    from_chat_id IntegerOrString [required]
    message_id int [required]
    caption string
    parse_mode string
    caption_entities []MessageEntity
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to copy messages of any kind. Service messages and invoice messages can't be copied. A quiz poll can be
// copied only if the value of the field correct_option_id is known to the bot. The method is analogous to the method
// forwardMessage, but the copied message doesn't have a link to the original message. Returns the MessageId of the
// sent message on success.
pub fn (ctx Context) copy_message(params CopyMessageParams) !MessageId {
    mut body := json.encode(params)
    mut raw_json := ctx.request("copyMessage", body)!
    res := json.decode(ApiResponse[MessageId], raw_json)!
    return res.result
}

// Params for the `send_photo` function.
pub struct SendPhotoParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    photo InputFileOrString [required]
    caption string
    parse_mode string
    caption_entities []MessageEntity
    has_spoiler bool
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send photos. On success, the sent Message is returned.
pub fn (ctx Context) send_photo(params SendPhotoParams) !Message {
    mut raw_json := ctx.request_multipart("sendPhoto", params)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_audio` function.
pub struct SendAudioParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    audio InputFileOrString [required]
    caption string
    parse_mode string
    caption_entities []MessageEntity
    duration int
    performer string
    title string
    thumbnail InputFileOrString
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send audio files, if you want Telegram clients to display them in the music player. Your audio must
// be in the .MP3 or .M4A format. On success, the sent Message is returned. Bots can currently send audio files of up to
// 50 MB in size, this limit may be changed in the future.
// For sending voice messages, use the sendVoice method instead.
pub fn (ctx Context) send_audio(params SendAudioParams) !Message {
    mut raw_json := ctx.request_multipart("sendAudio", params)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_document` function.
pub struct SendDocumentParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    document InputFileOrString [required]
    thumbnail InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    disable_content_type_detection bool
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send general files. On success, the sent Message is returned. Bots can currently send files of any
// type of up to 50 MB in size, this limit may be changed in the future.
pub fn (ctx Context) send_document(params SendDocumentParams) !Message {
    mut raw_json := ctx.request_multipart("sendDocument", params)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_video` function.
pub struct SendVideoParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    video InputFileOrString [required]
    duration int
    width int
    height int
    thumbnail InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    has_spoiler bool
    supports_streaming bool
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be sent as Document). On
// success, the sent Message is returned. Bots can currently send video files of up to 50 MB in size, this limit may be
// changed in the future.
pub fn (ctx Context) send_video(params SendVideoParams) !Message {
    mut raw_json := ctx.request_multipart("sendVideo", params)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_animation` function.
pub struct SendAnimationParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    animation InputFileOrString [required]
    duration int
    width int
    height int
    thumbnail InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    has_spoiler bool
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success, the sent Message is
// returned. Bots can currently send animation files of up to 50 MB in size, this limit may be changed in the future.
pub fn (ctx Context) send_animation(params SendAnimationParams) !Message {
    mut raw_json := ctx.request_multipart("sendAnimation", params)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_voice` function.
pub struct SendVoiceParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    voice InputFileOrString [required]
    caption string
    parse_mode string
    caption_entities []MessageEntity
    duration int
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send audio files, if you want Telegram clients to display the file as a playable voice message. For
// this to work, your audio must be in an .OGG file encoded with OPUS (other formats may be sent as Audio or Document).
// On success, the sent Message is returned. Bots can currently send voice messages of up to 50 MB in size, this limit
// may be changed in the future.
pub fn (ctx Context) send_voice(params SendVoiceParams) !Message {
    mut raw_json := ctx.request_multipart("sendVoice", params)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_video_note` function.
pub struct SendVideoNoteParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    video_note InputFileOrString [required]
    duration int
    length int
    thumbnail InputFileOrString
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// As of v.4.0, Telegram clients support rounded square MPEG4 videos of up to 1 minute long. Use this method to send video
// messages. On success, the sent Message is returned.
pub fn (ctx Context) send_video_note(params SendVideoNoteParams) !Message {
    mut raw_json := ctx.request_multipart("sendVideoNote", params)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_media_group` function.
pub struct SendMediaGroupParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    media []InputMediaAudioOrInputMediaDocumentOrInputMediaPhotoOrInputMediaVideo [required]
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
}

// Use this method to send a group of photos, videos, documents or audios as an album. Documents and audio files can be
// only grouped in an album with messages of the same type. On success, an array of Messages that were sent is
// returned.
pub fn (ctx Context) send_media_group(params SendMediaGroupParams) ![]Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendMediaGroup", body)!
    res := json.decode(ApiResponse[[]Message], raw_json)!
    return res.result
}

// Params for the `send_location` function.
pub struct SendLocationParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    latitude f64 [required]
    longitude f64 [required]
    horizontal_accuracy f64
    live_period int
    heading int
    proximity_alert_radius int
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send point on the map. On success, the sent Message is returned.
pub fn (ctx Context) send_location(params SendLocationParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendLocation", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_venue` function.
pub struct SendVenueParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    latitude f64 [required]
    longitude f64 [required]
    title string [required]
    address string [required]
    foursquare_id string
    foursquare_type string
    google_place_id string
    google_place_type string
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send information about a venue. On success, the sent Message is returned.
pub fn (ctx Context) send_venue(params SendVenueParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendVenue", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_contact` function.
pub struct SendContactParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    phone_number string [required]
    first_name string [required]
    last_name string
    vcard string
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send phone contacts. On success, the sent Message is returned.
pub fn (ctx Context) send_contact(params SendContactParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendContact", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_poll` function.
pub struct SendPollParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    question string [required]
    options []string [required]
    is_anonymous bool
    @type string
    allows_multiple_answers bool
    correct_option_id int
    explanation string
    explanation_parse_mode string
    explanation_entities []MessageEntity
    open_period int
    close_date int
    is_closed bool
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send a native poll. On success, the sent Message is returned.
pub fn (ctx Context) send_poll(params SendPollParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendPoll", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_dice` function.
pub struct SendDiceParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    emoji string
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send an animated emoji that will display a random value. On success, the sent Message is returned.
pub fn (ctx Context) send_dice(params SendDiceParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendDice", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_chat_action` function.
pub struct SendChatActionParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    action string [required]
}

// Use this method when you need to tell the user that something is happening on the bot's side. The status is set for 5
// seconds or less (when a message arrives from your bot, Telegram clients clear its typing status). Returns True on
// success.
// We only recommend using this method when a response from the bot will take a noticeable amount of time to arrive.
pub fn (ctx Context) send_chat_action(params SendChatActionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendChatAction", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_user_profile_photos` function.
pub struct GetUserProfilePhotosParams {
pub mut:
    user_id int [required]
    offset int
    limit int
}

// Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos object.
pub fn (ctx Context) get_user_profile_photos(params GetUserProfilePhotosParams) !UserProfilePhotos {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getUserProfilePhotos", body)!
    res := json.decode(ApiResponse[UserProfilePhotos], raw_json)!
    return res.result
}

// Params for the `get_file` function.
pub struct GetFileParams {
pub mut:
    file_id string [required]
}

// Use this method to get basic information about a file and prepare it for downloading. For the moment, bots can download
// files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link
// https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken from the response. It is
// guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be
// requested by calling getFile again.
// Note: This function may not preserve the original file name and MIME type. You should save the file's MIME type and
// name (if available) when the File object is received.
pub fn (ctx Context) get_file(params GetFileParams) !File {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getFile", body)!
    res := json.decode(ApiResponse[File], raw_json)!
    return res.result
}

// Params for the `ban_chat_member` function.
pub struct BanChatMemberParams {
pub mut:
    chat_id IntegerOrString [required]
    user_id int [required]
    until_date int
    revoke_messages bool
}

// Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups and channels, the user
// will not be able to return to the chat on their own using invite links, etc., unless unbanned first. The bot must be
// an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on
// success.
pub fn (ctx Context) ban_chat_member(params BanChatMemberParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("banChatMember", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unban_chat_member` function.
pub struct UnbanChatMemberParams {
pub mut:
    chat_id IntegerOrString [required]
    user_id int [required]
    only_if_banned bool
}

// Use this method to unban a previously banned user in a supergroup or channel. The user will not return to the group or
// channel automatically, but will be able to join via link, etc. The bot must be an administrator for this to work. By
// default, this method guarantees that after the call the user is not a member of the chat, but will be able to join
// it. So if the user is a member of the chat they will also be removed from the chat. If you don't want this, use
// the parameter only_if_banned. Returns True on success.
pub fn (ctx Context) unban_chat_member(params UnbanChatMemberParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unbanChatMember", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `restrict_chat_member` function.
pub struct RestrictChatMemberParams {
pub mut:
    chat_id IntegerOrString [required]
    user_id int [required]
    permissions ChatPermissions [required]
    use_independent_chat_permissions bool
    until_date int
}

// Use this method to restrict a user in a supergroup. The bot must be an administrator in the supergroup for this to work
// and must have the appropriate administrator rights. Pass True for all permissions to lift restrictions from a user.
// Returns True on success.
pub fn (ctx Context) restrict_chat_member(params RestrictChatMemberParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("restrictChatMember", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `promote_chat_member` function.
pub struct PromoteChatMemberParams {
pub mut:
    chat_id IntegerOrString [required]
    user_id int [required]
    is_anonymous bool
    can_manage_chat bool
    can_post_messages bool
    can_edit_messages bool
    can_delete_messages bool
    can_manage_video_chats bool
    can_restrict_members bool
    can_promote_members bool
    can_change_info bool
    can_invite_users bool
    can_pin_messages bool
    can_manage_topics bool
}

// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in the chat
// for this to work and must have the appropriate administrator rights. Pass False for all boolean parameters to demote a
// user. Returns True on success.
pub fn (ctx Context) promote_chat_member(params PromoteChatMemberParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("promoteChatMember", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_administrator_custom_title` function.
pub struct SetChatAdministratorCustomTitleParams {
pub mut:
    chat_id IntegerOrString [required]
    user_id int [required]
    custom_title string [required]
}

// Use this method to set a custom title for an administrator in a supergroup promoted by the bot. Returns True on
// success.
pub fn (ctx Context) set_chat_administrator_custom_title(params SetChatAdministratorCustomTitleParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatAdministratorCustomTitle", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `ban_chat_sender_chat` function.
pub struct BanChatSenderChatParams {
pub mut:
    chat_id IntegerOrString [required]
    sender_chat_id int [required]
}

// Use this method to ban a channel chat in a supergroup or a channel. Until the chat is unbanned, the owner of the banned
// chat won't be able to send messages on behalf of any of their channels. The bot must be an administrator in the
// supergroup or channel for this to work and must have the appropriate administrator rights. Returns True on
// success.
pub fn (ctx Context) ban_chat_sender_chat(params BanChatSenderChatParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("banChatSenderChat", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unban_chat_sender_chat` function.
pub struct UnbanChatSenderChatParams {
pub mut:
    chat_id IntegerOrString [required]
    sender_chat_id int [required]
}

// Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must be an administrator
// for this to work and must have the appropriate administrator rights. Returns True on success.
pub fn (ctx Context) unban_chat_sender_chat(params UnbanChatSenderChatParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unbanChatSenderChat", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_permissions` function.
pub struct SetChatPermissionsParams {
pub mut:
    chat_id IntegerOrString [required]
    permissions ChatPermissions [required]
    use_independent_chat_permissions bool
}

// Use this method to set default chat permissions for all members. The bot must be an administrator in the group or a
// supergroup for this to work and must have the can_restrict_members administrator rights. Returns True on success.
pub fn (ctx Context) set_chat_permissions(params SetChatPermissionsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatPermissions", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `export_chat_invite_link` function.
pub struct ExportChatInviteLinkParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to generate a new primary invite link for a chat; any previously generated primary link is revoked. The
// bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns
// the new invite link as String on success.
pub fn (ctx Context) export_chat_invite_link(params ExportChatInviteLinkParams) !string {
    mut body := json.encode(params)
    mut raw_json := ctx.request("exportChatInviteLink", body)!
    res := json.decode(ApiResponse[string], raw_json)!
    return res.result
}

// Params for the `create_chat_invite_link` function.
pub struct CreateChatInviteLinkParams {
pub mut:
    chat_id IntegerOrString [required]
    name string
    expire_date int
    member_limit int
    creates_join_request bool
}

// Use this method to create an additional invite link for a chat. The bot must be an administrator in the chat for this
// to work and must have the appropriate administrator rights. The link can be revoked using the method
// revokeChatInviteLink. Returns the new invite link as ChatInviteLink object.
pub fn (ctx Context) create_chat_invite_link(params CreateChatInviteLinkParams) !ChatInviteLink {
    mut body := json.encode(params)
    mut raw_json := ctx.request("createChatInviteLink", body)!
    res := json.decode(ApiResponse[ChatInviteLink], raw_json)!
    return res.result
}

// Params for the `edit_chat_invite_link` function.
pub struct EditChatInviteLinkParams {
pub mut:
    chat_id IntegerOrString [required]
    invite_link string [required]
    name string
    expire_date int
    member_limit int
    creates_join_request bool
}

// Use this method to edit a non-primary invite link created by the bot. The bot must be an administrator in the chat for
// this to work and must have the appropriate administrator rights. Returns the edited invite link as a ChatInviteLink
// object.
pub fn (ctx Context) edit_chat_invite_link(params EditChatInviteLinkParams) !ChatInviteLink {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editChatInviteLink", body)!
    res := json.decode(ApiResponse[ChatInviteLink], raw_json)!
    return res.result
}

// Params for the `revoke_chat_invite_link` function.
pub struct RevokeChatInviteLinkParams {
pub mut:
    chat_id IntegerOrString [required]
    invite_link string [required]
}

// Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new link is
// automatically generated. The bot must be an administrator in the chat for this to work and must have the
// appropriate administrator rights. Returns the revoked invite link as ChatInviteLink object.
pub fn (ctx Context) revoke_chat_invite_link(params RevokeChatInviteLinkParams) !ChatInviteLink {
    mut body := json.encode(params)
    mut raw_json := ctx.request("revokeChatInviteLink", body)!
    res := json.decode(ApiResponse[ChatInviteLink], raw_json)!
    return res.result
}

// Params for the `approve_chat_join_request` function.
pub struct ApproveChatJoinRequestParams {
pub mut:
    chat_id IntegerOrString [required]
    user_id int [required]
}

// Use this method to approve a chat join request. The bot must be an administrator in the chat for this to work and must
// have the can_invite_users administrator right. Returns True on success.
pub fn (ctx Context) approve_chat_join_request(params ApproveChatJoinRequestParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("approveChatJoinRequest", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `decline_chat_join_request` function.
pub struct DeclineChatJoinRequestParams {
pub mut:
    chat_id IntegerOrString [required]
    user_id int [required]
}

// Use this method to decline a chat join request. The bot must be an administrator in the chat for this to work and must
// have the can_invite_users administrator right. Returns True on success.
pub fn (ctx Context) decline_chat_join_request(params DeclineChatJoinRequestParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("declineChatJoinRequest", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_photo` function.
pub struct SetChatPhotoParams {
pub mut:
    chat_id IntegerOrString [required]
    photo InputFile [required]
}

// Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on
// success.
pub fn (ctx Context) set_chat_photo(params SetChatPhotoParams) !bool {
    mut raw_json := ctx.request_multipart("setChatPhoto", params)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_chat_photo` function.
pub struct DeleteChatPhotoParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be an administrator in
// the chat for this to work and must have the appropriate administrator rights. Returns True on success.
pub fn (ctx Context) delete_chat_photo(params DeleteChatPhotoParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteChatPhoto", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_title` function.
pub struct SetChatTitleParams {
pub mut:
    chat_id IntegerOrString [required]
    title string [required]
}

// Use this method to change the title of a chat. Titles can't be changed for private chats. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights. Returns True
// on success.
pub fn (ctx Context) set_chat_title(params SetChatTitleParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatTitle", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_description` function.
pub struct SetChatDescriptionParams {
pub mut:
    chat_id IntegerOrString [required]
    description string
}

// Use this method to change the description of a group, a supergroup or a channel. The bot must be an administrator in
// the chat for this to work and must have the appropriate administrator rights. Returns True on success.
pub fn (ctx Context) set_chat_description(params SetChatDescriptionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatDescription", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `pin_chat_message` function.
pub struct PinChatMessageParams {
pub mut:
    chat_id IntegerOrString [required]
    message_id int [required]
    disable_notification bool
}

// Use this method to add a message to the list of pinned messages in a chat. If the chat is not a private chat, the bot
// must be an administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in a
// supergroup or 'can_edit_messages' administrator right in a channel. Returns True on success.
pub fn (ctx Context) pin_chat_message(params PinChatMessageParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("pinChatMessage", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unpin_chat_message` function.
pub struct UnpinChatMessageParams {
pub mut:
    chat_id IntegerOrString [required]
    message_id int
}

// Use this method to remove a message from the list of pinned messages in a chat. If the chat is not a private chat, the
// bot must be an administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in
// a supergroup or 'can_edit_messages' administrator right in a channel. Returns True on success.
pub fn (ctx Context) unpin_chat_message(params UnpinChatMessageParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unpinChatMessage", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unpin_all_chat_messages` function.
pub struct UnpinAllChatMessagesParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an
// administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in a supergroup
// or 'can_edit_messages' administrator right in a channel. Returns True on success.
pub fn (ctx Context) unpin_all_chat_messages(params UnpinAllChatMessagesParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unpinAllChatMessages", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `leave_chat` function.
pub struct LeaveChatParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method for your bot to leave a group, supergroup or channel. Returns True on success.
pub fn (ctx Context) leave_chat(params LeaveChatParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("leaveChat", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_chat` function.
pub struct GetChatParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to get up to date information about the chat (current name of the user for one-on-one conversations,
// current username of a user, group or channel, etc.). Returns a Chat object on success.
pub fn (ctx Context) get_chat(params GetChatParams) !Chat {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChat", body)!
    res := json.decode(ApiResponse[Chat], raw_json)!
    return res.result
}

// Params for the `get_chat_administrators` function.
pub struct GetChatAdministratorsParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array of ChatMember objects.
pub fn (ctx Context) get_chat_administrators(params GetChatAdministratorsParams) ![]ChatMember {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChatAdministrators", body)!
    res := json.decode(ApiResponse[[]ChatMember], raw_json)!
    return res.result
}

// Params for the `get_chat_member_count` function.
pub struct GetChatMemberCountParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to get the number of members in a chat. Returns Int on success.
pub fn (ctx Context) get_chat_member_count(params GetChatMemberCountParams) !int {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChatMemberCount", body)!
    res := json.decode(ApiResponse[int], raw_json)!
    return res.result
}

// Params for the `get_chat_member` function.
pub struct GetChatMemberParams {
pub mut:
    chat_id IntegerOrString [required]
    user_id int [required]
}

// Use this method to get information about a member of a chat. The method is only guaranteed to work for other users if
// the bot is an administrator in the chat. Returns a ChatMember object on success.
pub fn (ctx Context) get_chat_member(params GetChatMemberParams) !ChatMember {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChatMember", body)!
    res := json.decode(ApiResponse[ChatMember], raw_json)!
    return res.result
}

// Params for the `set_chat_sticker_set` function.
pub struct SetChatStickerSetParams {
pub mut:
    chat_id IntegerOrString [required]
    sticker_set_name string [required]
}

// Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat for this
// to work and must have the appropriate administrator rights. Use the field can_set_sticker_set optionally returned in
// getChat requests to check if the bot can use this method. Returns True on success.
pub fn (ctx Context) set_chat_sticker_set(params SetChatStickerSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatStickerSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_chat_sticker_set` function.
pub struct DeleteChatStickerSetParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to delete a group sticker set from a supergroup. The bot must be an administrator in the chat for this
// to work and must have the appropriate administrator rights. Use the field can_set_sticker_set optionally returned in
// getChat requests to check if the bot can use this method. Returns True on success.
pub fn (ctx Context) delete_chat_sticker_set(params DeleteChatStickerSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteChatStickerSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user. Requires no
// parameters. Returns an Array of Sticker objects.
pub fn (ctx Context) get_forum_topic_icon_stickers() ![]Sticker {
    mut body := "{}"
    mut raw_json := ctx.request("getForumTopicIconStickers", body)!
    res := json.decode(ApiResponse[[]Sticker], raw_json)!
    return res.result
}

// Params for the `create_forum_topic` function.
pub struct CreateForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
    name string [required]
    icon_color int
    icon_custom_emoji_id string
}

// Use this method to create a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to
// work and must have the can_manage_topics administrator rights. Returns information about the created topic as a
// ForumTopic object.
pub fn (ctx Context) create_forum_topic(params CreateForumTopicParams) !ForumTopic {
    mut body := json.encode(params)
    mut raw_json := ctx.request("createForumTopic", body)!
    res := json.decode(ApiResponse[ForumTopic], raw_json)!
    return res.result
}

// Params for the `edit_forum_topic` function.
pub struct EditForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int [required]
    name string
    icon_custom_emoji_id string
}

// Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an administrator in the
// chat for this to work and must have can_manage_topics administrator rights, unless it is the creator of the topic.
// Returns True on success.
pub fn (ctx Context) edit_forum_topic(params EditForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `close_forum_topic` function.
pub struct CloseForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int [required]
}

// Use this method to close an open topic in a forum supergroup chat. The bot must be an administrator in the chat for
// this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.
// Returns True on success.
pub fn (ctx Context) close_forum_topic(params CloseForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("closeForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `reopen_forum_topic` function.
pub struct ReopenForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int [required]
}

// Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an administrator in the chat for
// this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic. Returns
// True on success.
pub fn (ctx Context) reopen_forum_topic(params ReopenForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("reopenForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_forum_topic` function.
pub struct DeleteForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int [required]
}

// Use this method to delete a forum topic along with all its messages in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the can_delete_messages administrator rights. Returns
// True on success.
pub fn (ctx Context) delete_forum_topic(params DeleteForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unpin_all_forum_topic_messages` function.
pub struct UnpinAllForumTopicMessagesParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int [required]
}

// Use this method to clear the list of pinned messages in a forum topic. The bot must be an administrator in the chat for
// this to work and must have the can_pin_messages administrator right in the supergroup. Returns True on success.
pub fn (ctx Context) unpin_all_forum_topic_messages(params UnpinAllForumTopicMessagesParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unpinAllForumTopicMessages", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `edit_general_forum_topic` function.
pub struct EditGeneralForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
    name string [required]
}

// Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must be an administrator in
// the chat for this to work and must have can_manage_topics administrator rights. Returns True on success.
pub fn (ctx Context) edit_general_forum_topic(params EditGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `close_general_forum_topic` function.
pub struct CloseGeneralForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an administrator in the
// chat for this to work and must have the can_manage_topics administrator rights. Returns True on success.
pub fn (ctx Context) close_general_forum_topic(params CloseGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("closeGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `reopen_general_forum_topic` function.
pub struct ReopenGeneralForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be an administrator in the
// chat for this to work and must have the can_manage_topics administrator rights. The topic will be automatically
// unhidden if it was hidden. Returns True on success.
pub fn (ctx Context) reopen_general_forum_topic(params ReopenGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("reopenGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `hide_general_forum_topic` function.
pub struct HideGeneralForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat
// for this to work and must have the can_manage_topics administrator rights. The topic will be automatically closed if
// it was open. Returns True on success.
pub fn (ctx Context) hide_general_forum_topic(params HideGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("hideGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unhide_general_forum_topic` function.
pub struct UnhideGeneralForumTopicParams {
pub mut:
    chat_id IntegerOrString [required]
}

// Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat
// for this to work and must have the can_manage_topics administrator rights. Returns True on success.
pub fn (ctx Context) unhide_general_forum_topic(params UnhideGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unhideGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `answer_callback_query` function.
pub struct AnswerCallbackQueryParams {
pub mut:
    callback_query_id string [required]
    text string
    show_alert bool
    url string
    cache_time int
}

// Use this method to send answers to callback queries sent from inline keyboards. The answer will be displayed to the
// user as a notification at the top of the chat screen or as an alert. On success, True is returned.
pub fn (ctx Context) answer_callback_query(params AnswerCallbackQueryParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerCallbackQuery", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_my_commands` function.
pub struct SetMyCommandsParams {
pub mut:
    commands []BotCommand [required]
    scope BotCommandScope
    language_code string
}

// Use this method to change the list of the bot's commands. See this manual for more details about bot commands. Returns
// True on success.
pub fn (ctx Context) set_my_commands(params SetMyCommandsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyCommands", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_my_commands` function.
pub struct DeleteMyCommandsParams {
pub mut:
    scope BotCommandScope
    language_code string
}

// Use this method to delete the list of the bot's commands for the given scope and user language. After deletion, higher
// level commands will be shown to affected users. Returns True on success.
pub fn (ctx Context) delete_my_commands(params DeleteMyCommandsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteMyCommands", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_commands` function.
pub struct GetMyCommandsParams {
pub mut:
    scope BotCommandScope
    language_code string
}

// Use this method to get the current list of the bot's commands for the given scope and user language. Returns an Array
// of BotCommand objects. If commands aren't set, an empty list is returned.
pub fn (ctx Context) get_my_commands(params GetMyCommandsParams) ![]BotCommand {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyCommands", body)!
    res := json.decode(ApiResponse[[]BotCommand], raw_json)!
    return res.result
}

// Params for the `set_my_name` function.
pub struct SetMyNameParams {
pub mut:
    name string
    language_code string
}

// Use this method to change the bot's name. Returns True on success.
pub fn (ctx Context) set_my_name(params SetMyNameParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyName", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_name` function.
pub struct GetMyNameParams {
pub mut:
    language_code string
}

// Use this method to get the current bot name for the given user language. Returns BotName on success.
pub fn (ctx Context) get_my_name(params GetMyNameParams) !BotName {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyName", body)!
    res := json.decode(ApiResponse[BotName], raw_json)!
    return res.result
}

// Params for the `set_my_description` function.
pub struct SetMyDescriptionParams {
pub mut:
    description string
    language_code string
}

// Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty. Returns
// True on success.
pub fn (ctx Context) set_my_description(params SetMyDescriptionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyDescription", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_description` function.
pub struct GetMyDescriptionParams {
pub mut:
    language_code string
}

// Use this method to get the current bot description for the given user language. Returns BotDescription on success.
pub fn (ctx Context) get_my_description(params GetMyDescriptionParams) !BotDescription {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyDescription", body)!
    res := json.decode(ApiResponse[BotDescription], raw_json)!
    return res.result
}

// Params for the `set_my_short_description` function.
pub struct SetMyShortDescriptionParams {
pub mut:
    short_description string
    language_code string
}

// Use this method to change the bot's short description, which is shown on the bot's profile page and is sent together
// with the link when users share the bot. Returns True on success.
pub fn (ctx Context) set_my_short_description(params SetMyShortDescriptionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyShortDescription", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_short_description` function.
pub struct GetMyShortDescriptionParams {
pub mut:
    language_code string
}

// Use this method to get the current bot short description for the given user language. Returns BotShortDescription on
// success.
pub fn (ctx Context) get_my_short_description(params GetMyShortDescriptionParams) !BotShortDescription {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyShortDescription", body)!
    res := json.decode(ApiResponse[BotShortDescription], raw_json)!
    return res.result
}

// Params for the `set_chat_menu_button` function.
pub struct SetChatMenuButtonParams {
pub mut:
    chat_id int
    menu_button MenuButton
}

// Use this method to change the bot's menu button in a private chat, or the default menu button. Returns True on success.
pub fn (ctx Context) set_chat_menu_button(params SetChatMenuButtonParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatMenuButton", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_chat_menu_button` function.
pub struct GetChatMenuButtonParams {
pub mut:
    chat_id int
}

// Use this method to get the current value of the bot's menu button in a private chat, or the default menu button.
// Returns MenuButton on success.
pub fn (ctx Context) get_chat_menu_button(params GetChatMenuButtonParams) !MenuButton {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChatMenuButton", body)!
    res := json.decode(ApiResponse[MenuButton], raw_json)!
    return res.result
}

// Params for the `set_my_default_administrator_rights` function.
pub struct SetMyDefaultAdministratorRightsParams {
pub mut:
    rights ChatAdministratorRights
    for_channels bool
}

// Use this method to change the default administrator rights requested by the bot when it's added as an administrator to
// groups or channels. These rights will be suggested to users, but they are free to modify the list before adding the
// bot. Returns True on success.
pub fn (ctx Context) set_my_default_administrator_rights(params SetMyDefaultAdministratorRightsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyDefaultAdministratorRights", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_default_administrator_rights` function.
pub struct GetMyDefaultAdministratorRightsParams {
pub mut:
    for_channels bool
}

// Use this method to get the current default administrator rights of the bot. Returns ChatAdministratorRights on success.
pub fn (ctx Context) get_my_default_administrator_rights(params GetMyDefaultAdministratorRightsParams) !ChatAdministratorRights {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyDefaultAdministratorRights", body)!
    res := json.decode(ApiResponse[ChatAdministratorRights], raw_json)!
    return res.result
}

// Params for the `edit_message_text` function.
pub struct EditMessageTextParams {
pub mut:
    chat_id IntegerOrString
    message_id int
    inline_message_id string
    text string [required]
    parse_mode string
    entities []MessageEntity
    disable_web_page_preview bool
    reply_markup InlineKeyboardMarkup
}

// Use this method to edit text and game messages. On success, if the edited message is not an inline message, the edited
// Message is returned, otherwise True is returned.
pub fn (ctx Context) edit_message_text(params EditMessageTextParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageText", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `edit_message_caption` function.
pub struct EditMessageCaptionParams {
pub mut:
    chat_id IntegerOrString
    message_id int
    inline_message_id string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup InlineKeyboardMarkup
}

// Use this method to edit captions of messages. On success, if the edited message is not an inline message, the edited
// Message is returned, otherwise True is returned.
pub fn (ctx Context) edit_message_caption(params EditMessageCaptionParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageCaption", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `edit_message_media` function.
pub struct EditMessageMediaParams {
pub mut:
    chat_id IntegerOrString
    message_id int
    inline_message_id string
    media InputMedia [required]
    reply_markup InlineKeyboardMarkup
}

// Use this method to edit animation, audio, document, photo, or video messages. If a message is part of a message album,
// then it can be edited only to an audio for audio albums, only to a document for document albums and to a photo or a
// video otherwise. When an inline message is edited, a new file can't be uploaded; use a previously uploaded file via
// its file_id or specify a URL. On success, if the edited message is not an inline message, the edited Message is
// returned, otherwise True is returned.
pub fn (ctx Context) edit_message_media(params EditMessageMediaParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageMedia", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `edit_message_live_location` function.
pub struct EditMessageLiveLocationParams {
pub mut:
    chat_id IntegerOrString
    message_id int
    inline_message_id string
    latitude f64 [required]
    longitude f64 [required]
    horizontal_accuracy f64
    heading int
    proximity_alert_radius int
    reply_markup InlineKeyboardMarkup
}

// Use this method to edit live location messages. A location can be edited until its live_period expires or editing is
// explicitly disabled by a call to stopMessageLiveLocation. On success, if the edited message is not an inline
// message, the edited Message is returned, otherwise True is returned.
pub fn (ctx Context) edit_message_live_location(params EditMessageLiveLocationParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageLiveLocation", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `stop_message_live_location` function.
pub struct StopMessageLiveLocationParams {
pub mut:
    chat_id IntegerOrString
    message_id int
    inline_message_id string
    reply_markup InlineKeyboardMarkup
}

// Use this method to stop updating a live location message before live_period expires. On success, if the message is not
// an inline message, the edited Message is returned, otherwise True is returned.
pub fn (ctx Context) stop_message_live_location(params StopMessageLiveLocationParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("stopMessageLiveLocation", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `edit_message_reply_markup` function.
pub struct EditMessageReplyMarkupParams {
pub mut:
    chat_id IntegerOrString
    message_id int
    inline_message_id string
    reply_markup InlineKeyboardMarkup
}

// Use this method to edit only the reply markup of messages. On success, if the edited message is not an inline message,
// the edited Message is returned, otherwise True is returned.
pub fn (ctx Context) edit_message_reply_markup(params EditMessageReplyMarkupParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageReplyMarkup", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `stop_poll` function.
pub struct StopPollParams {
pub mut:
    chat_id IntegerOrString [required]
    message_id int [required]
    reply_markup InlineKeyboardMarkup
}

// Use this method to stop a poll which was sent by the bot. On success, the stopped Poll is returned.
pub fn (ctx Context) stop_poll(params StopPollParams) !Poll {
    mut body := json.encode(params)
    mut raw_json := ctx.request("stopPoll", body)!
    res := json.decode(ApiResponse[Poll], raw_json)!
    return res.result
}

// Params for the `delete_message` function.
pub struct DeleteMessageParams {
pub mut:
    chat_id IntegerOrString [required]
    message_id int [required]
}

// Use this method to delete a message, including service messages, with the following limitations:
// - A message can only be deleted if it was sent less than 48 hours ago.
// - Service messages about a supergroup, channel, or forum topic creation can't be deleted.
// - A dice message in a private chat can only be deleted if it was sent more than 24 hours ago.
// - Bots can delete outgoing messages in private chats, groups, and supergroups.
// - Bots can delete incoming messages in private chats.
// - Bots granted can_post_messages permissions can delete outgoing messages in channels.
// - If the bot is an administrator of a group, it can delete any message there.
// - If the bot has can_delete_messages permission in a supergroup or a channel, it can delete any message there.
// Returns True on success.
pub fn (ctx Context) delete_message(params DeleteMessageParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteMessage", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `send_sticker` function.
pub struct SendStickerParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    sticker InputFileOrString [required]
    emoji string
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply
}

// Use this method to send static .WEBP, animated .TGS, or video .WEBM stickers. On success, the sent Message is returned.
pub fn (ctx Context) send_sticker(params SendStickerParams) !Message {
    mut raw_json := ctx.request_multipart("sendSticker", params)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `get_sticker_set` function.
pub struct GetStickerSetParams {
pub mut:
    name string [required]
}

// Use this method to get a sticker set. On success, a StickerSet object is returned.
pub fn (ctx Context) get_sticker_set(params GetStickerSetParams) !StickerSet {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getStickerSet", body)!
    res := json.decode(ApiResponse[StickerSet], raw_json)!
    return res.result
}

// Params for the `get_custom_emoji_stickers` function.
pub struct GetCustomEmojiStickersParams {
pub mut:
    custom_emoji_ids []string [required]
}

// Use this method to get information about custom emoji stickers by their identifiers. Returns an Array of Sticker
// objects.
pub fn (ctx Context) get_custom_emoji_stickers(params GetCustomEmojiStickersParams) ![]Sticker {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getCustomEmojiStickers", body)!
    res := json.decode(ApiResponse[[]Sticker], raw_json)!
    return res.result
}

// Params for the `upload_sticker_file` function.
pub struct UploadStickerFileParams {
pub mut:
    user_id int [required]
    sticker InputFile [required]
    sticker_format string [required]
}

// Use this method to upload a file with a sticker for later use in the createNewStickerSet and addStickerToSet methods
// (the file can be used multiple times). Returns the uploaded File on success.
pub fn (ctx Context) upload_sticker_file(params UploadStickerFileParams) !File {
    mut raw_json := ctx.request_multipart("uploadStickerFile", params)!
    res := json.decode(ApiResponse[File], raw_json)!
    return res.result
}

// Params for the `create_new_sticker_set` function.
pub struct CreateNewStickerSetParams {
pub mut:
    user_id int [required]
    name string [required]
    title string [required]
    stickers []InputSticker [required]
    sticker_format string [required]
    sticker_type string
    needs_repainting bool
}

// Use this method to create a new sticker set owned by a user. The bot will be able to edit the sticker set thus created.
// Returns True on success.
pub fn (ctx Context) create_new_sticker_set(params CreateNewStickerSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("createNewStickerSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `add_sticker_to_set` function.
pub struct AddStickerToSetParams {
pub mut:
    user_id int [required]
    name string [required]
    sticker InputSticker [required]
}

// Use this method to add a new sticker to a set created by the bot. The format of the added sticker must match the format
// of the other stickers in the set. Emoji sticker sets can have up to 200 stickers. Animated and video sticker sets can
// have up to 50 stickers. Static sticker sets can have up to 120 stickers. Returns True on success.
pub fn (ctx Context) add_sticker_to_set(params AddStickerToSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("addStickerToSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_position_in_set` function.
pub struct SetStickerPositionInSetParams {
pub mut:
    sticker string [required]
    position int [required]
}

// Use this method to move a sticker in a set created by the bot to a specific position. Returns True on success.
pub fn (ctx Context) set_sticker_position_in_set(params SetStickerPositionInSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerPositionInSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_sticker_from_set` function.
pub struct DeleteStickerFromSetParams {
pub mut:
    sticker string [required]
}

// Use this method to delete a sticker from a set created by the bot. Returns True on success.
pub fn (ctx Context) delete_sticker_from_set(params DeleteStickerFromSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteStickerFromSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_emoji_list` function.
pub struct SetStickerEmojiListParams {
pub mut:
    sticker string [required]
    emoji_list []string [required]
}

// Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The sticker must belong to a
// sticker set created by the bot. Returns True on success.
pub fn (ctx Context) set_sticker_emoji_list(params SetStickerEmojiListParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerEmojiList", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_keywords` function.
pub struct SetStickerKeywordsParams {
pub mut:
    sticker string [required]
    keywords []string
}

// Use this method to change search keywords assigned to a regular or custom emoji sticker. The sticker must belong to a
// sticker set created by the bot. Returns True on success.
pub fn (ctx Context) set_sticker_keywords(params SetStickerKeywordsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerKeywords", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_mask_position` function.
pub struct SetStickerMaskPositionParams {
pub mut:
    sticker string [required]
    mask_position MaskPosition
}

// Use this method to change the mask position of a mask sticker. The sticker must belong to a sticker set that was
// created by the bot. Returns True on success.
pub fn (ctx Context) set_sticker_mask_position(params SetStickerMaskPositionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerMaskPosition", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_set_title` function.
pub struct SetStickerSetTitleParams {
pub mut:
    name string [required]
    title string [required]
}

// Use this method to set the title of a created sticker set. Returns True on success.
pub fn (ctx Context) set_sticker_set_title(params SetStickerSetTitleParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerSetTitle", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_set_thumbnail` function.
pub struct SetStickerSetThumbnailParams {
pub mut:
    name string [required]
    user_id int [required]
    thumbnail InputFileOrString
}

// Use this method to set the thumbnail of a regular or mask sticker set. The format of the thumbnail file must match the
// format of the stickers in the set. Returns True on success.
pub fn (ctx Context) set_sticker_set_thumbnail(params SetStickerSetThumbnailParams) !bool {
    mut raw_json := ctx.request_multipart("setStickerSetThumbnail", params)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_custom_emoji_sticker_set_thumbnail` function.
pub struct SetCustomEmojiStickerSetThumbnailParams {
pub mut:
    name string [required]
    custom_emoji_id string
}

// Use this method to set the thumbnail of a custom emoji sticker set. Returns True on success.
pub fn (ctx Context) set_custom_emoji_sticker_set_thumbnail(params SetCustomEmojiStickerSetThumbnailParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setCustomEmojiStickerSetThumbnail", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_sticker_set` function.
pub struct DeleteStickerSetParams {
pub mut:
    name string [required]
}

// Use this method to delete a sticker set that was created by the bot. Returns True on success.
pub fn (ctx Context) delete_sticker_set(params DeleteStickerSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteStickerSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `answer_inline_query` function.
pub struct AnswerInlineQueryParams {
pub mut:
    inline_query_id string [required]
    results []InlineQueryResult [required]
    cache_time int
    is_personal bool
    next_offset string
    button InlineQueryResultsButton
}

// Use this method to send answers to an inline query. On success, True is returned.
// No more than 50 results per query are allowed.
pub fn (ctx Context) answer_inline_query(params AnswerInlineQueryParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerInlineQuery", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `answer_web_app_query` function.
pub struct AnswerWebAppQueryParams {
pub mut:
    web_app_query_id string [required]
    result InlineQueryResult [required]
}

// Use this method to set the result of an interaction with a Web App and send a corresponding message on behalf of the
// user to the chat from which the query originated. On success, a SentWebAppMessage object is returned.
pub fn (ctx Context) answer_web_app_query(params AnswerWebAppQueryParams) !SentWebAppMessage {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerWebAppQuery", body)!
    res := json.decode(ApiResponse[SentWebAppMessage], raw_json)!
    return res.result
}

// Params for the `send_invoice` function.
pub struct SendInvoiceParams {
pub mut:
    chat_id IntegerOrString [required]
    message_thread_id int
    title string [required]
    description string [required]
    payload string [required]
    provider_token string [required]
    currency string [required]
    prices []LabeledPrice [required]
    max_tip_amount int
    suggested_tip_amounts []int
    start_parameter string
    provider_data string
    photo_url string
    photo_size int
    photo_width int
    photo_height int
    need_name bool
    need_phone_number bool
    need_email bool
    need_shipping_address bool
    send_phone_number_to_provider bool
    send_email_to_provider bool
    is_flexible bool
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkup
}

// Use this method to send invoices. On success, the sent Message is returned.
pub fn (ctx Context) send_invoice(params SendInvoiceParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendInvoice", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `create_invoice_link` function.
pub struct CreateInvoiceLinkParams {
pub mut:
    title string [required]
    description string [required]
    payload string [required]
    provider_token string [required]
    currency string [required]
    prices []LabeledPrice [required]
    max_tip_amount int
    suggested_tip_amounts []int
    provider_data string
    photo_url string
    photo_size int
    photo_width int
    photo_height int
    need_name bool
    need_phone_number bool
    need_email bool
    need_shipping_address bool
    send_phone_number_to_provider bool
    send_email_to_provider bool
    is_flexible bool
}

// Use this method to create a link for an invoice. Returns the created invoice link as String on success.
pub fn (ctx Context) create_invoice_link(params CreateInvoiceLinkParams) !string {
    mut body := json.encode(params)
    mut raw_json := ctx.request("createInvoiceLink", body)!
    res := json.decode(ApiResponse[string], raw_json)!
    return res.result
}

// Params for the `answer_shipping_query` function.
pub struct AnswerShippingQueryParams {
pub mut:
    shipping_query_id string [required]
    ok bool [required]
    shipping_options []ShippingOption
    error_message string
}

// If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the Bot API will send
// an Update with a shipping_query field to the bot. Use this method to reply to shipping queries. On success, True is
// returned.
pub fn (ctx Context) answer_shipping_query(params AnswerShippingQueryParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerShippingQuery", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `answer_pre_checkout_query` function.
pub struct AnswerPreCheckoutQueryParams {
pub mut:
    pre_checkout_query_id string [required]
    ok bool [required]
    error_message string
}

// Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of
// an Update with the field pre_checkout_query. Use this method to respond to such pre-checkout queries. On success, True
// is returned. Note: The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.
pub fn (ctx Context) answer_pre_checkout_query(params AnswerPreCheckoutQueryParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerPreCheckoutQuery", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_passport_data_errors` function.
pub struct SetPassportDataErrorsParams {
pub mut:
    user_id int [required]
    errors []PassportElementError [required]
}

// Informs a user that some of the Telegram Passport elements they provided contains errors. The user will not be able to
// re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error
// must change). Returns True on success.
// Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For
// example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering,
// etc. Supply some details in the error message to make sure the user knows how to correct the issues.
pub fn (ctx Context) set_passport_data_errors(params SetPassportDataErrorsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setPassportDataErrors", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `send_game` function.
pub struct SendGameParams {
pub mut:
    chat_id int [required]
    message_thread_id int
    game_short_name string [required]
    disable_notification bool
    protect_content bool
    reply_to_message_id int
    allow_sending_without_reply bool
    reply_markup InlineKeyboardMarkup
}

// Use this method to send a game. On success, the sent Message is returned.
pub fn (ctx Context) send_game(params SendGameParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendGame", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `set_game_score` function.
pub struct SetGameScoreParams {
pub mut:
    user_id int [required]
    score int [required]
    force bool
    disable_edit_message bool
    chat_id int
    message_id int
    inline_message_id string
}

// Use this method to set the score of the specified user in a game message. On success, if the message is not an inline
// message, the Message is returned, otherwise True is returned. Returns an error, if the new score is not greater than
// the user's current score in the chat and force is False.
pub fn (ctx Context) set_game_score(params SetGameScoreParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setGameScore", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `get_game_high_scores` function.
pub struct GetGameHighScoresParams {
pub mut:
    user_id int [required]
    chat_id int
    message_id int
    inline_message_id string
}

// Use this method to get data for high score tables. Will return the score of the specified user and several of their
// neighbors in a game. Returns an Array of GameHighScore objects.
pub fn (ctx Context) get_game_high_scores(params GetGameHighScoresParams) ![]GameHighScore {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getGameHighScores", body)!
    res := json.decode(ApiResponse[[]GameHighScore], raw_json)!
    return res.result
}

