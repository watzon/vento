module main

import os
import json
import strings
import net.http

const (
	output_file   = os.abs_path(os.join_path(os.getwd(), "src", "api.v"))
	api_json_endpoint = "https://raw.githubusercontent.com/PaulSonOfLars/telegram-bot-api-spec/master/api.min.json"

	banner = "// This file was auto-generated by generator.vsh. Do not edit manually."
)

fn fetch_spec() JsonSpec {
	res := http.get(api_json_endpoint) or { panic(err) }
	return json.decode(JsonSpec, res.body) or { panic(err) }
}

fn write_header(mut sb strings.Builder) {
	sb.writeln(banner)
	sb.writeln("module main")
	sb.writeln("")
	sb.writeln("import json")
	sb.writeln("import net.http")
	sb.writeln("")
}

fn write_sum_types(mut sb strings.Builder, sum_types []ApiSumType) {
	for @type in sum_types {
		sb.writeln("pub type ${@type.name} = ${@type.value}")
		sb.writeln("")
	}
}

fn write_interfaces(mut sb strings.Builder, interfaces []ApiInterface) {
	for @interface in interfaces {
		for line in @interface.description {
			sb.writeln("// ${line}")
		}
		sb.writeln("pub type ${@interface.name} = ${@interface.structs.join(" | ")}")
		sb.writeln("")
	}
}

fn write_structs(mut sb strings.Builder, structs []ApiStruct) {
	for @struct in structs {
		if @struct.name in overridden_types {
			continue
		}

		for line in @struct.description {
			sb.writeln("// ${line}")
		}

		if @struct.fields.len > 0 {
			sb.writeln("pub struct ${@struct.name} {")
			sb.writeln("pub:")
			for field in @struct.fields {
				sb.write_string("    ${field.name} ")
				if !field.is_primitive() {
					if !field.required {
						sb.write_string("?")
					}
					sb.write_string("&")
				}
				sb.write_string(field.@type)
				if @struct.name in defaults && field.name in defaults[@struct.name] {
					sb.write_string(" = ${defaults[@struct.name][field.name]}")
				}
				sb.writeln("")
			}
			sb.writeln("}")
		} else {
			sb.writeln("pub struct ${@struct.name} {}")
		}

		sb.writeln("")
	}
}

fn write_functions(mut sb strings.Builder, api Api) {
	for func in api.functions {
		params_struct_name := "${to_camel_case(func.name, true)}Params"

		// First generate a params struct
		if func.params.len > 0 {
			sb.writeln("// Params for the `${func.name}` function.")
			sb.writeln("[params]")
			sb.writeln("pub struct ${params_struct_name} {")
			sb.writeln("pub mut:")
			for param in func.params {
				for line in param.description {
					sb.writeln("    // ${line}")
				}
				sb.write_string("    ${param.name} ")
				if param.@type in api.sum_types {
					if api.sum_types[param.@type].array_of {
						sb.write_string("[]")
					}
				}
				sb.write_string("${param.@type}")
				if param.required {
					sb.write_string(" [required]")
				}
				sb.write_string("\n\n")
			}
			sb.writeln("}")
			sb.writeln("")
		}

		// Write out the comment
		for line in func.description {
			sb.writeln("// ${line}")
		}

		// Write out the function itself
		if func.params.len > 0 {
			sb.writeln("pub fn (ctx Context) ${func.name}(params $params_struct_name) !${func.returns} {")
		} else {
			sb.writeln("pub fn (ctx Context) ${func.name}() !${func.returns} {")
		}

		multipart := func.params.any(fn (param ApiField) bool {
			return param.@type.contains("InputFile")
		})

		if multipart {
			file_params := func.params.filter(fn (param ApiField) bool {
				return param.@type == "InputFile"
			})

			maybe_file_params := func.params.filter(fn (param ApiField) bool {
				return param.@type == "InputFileOrString"
			})

			form_params := func.params.filter(fn (param ApiField) bool {
				return !param.@type.contains("InputFile")
			})

			sb.writeln("    mut form := http.PostMultipartFormConfig{")
			if form_params.len > 0 {
				sb.writeln("        form: {")
				for param in form_params {
					// Primitive types should be converted to strings with `.str()`,
					// other types should be converted to JSON.
					if param.is_primitive() {
						if param.@type == "string" {
							sb.writeln("            \"${param.name}\": params.${param.name},")
						} else {
							sb.writeln("            \"${param.name}\": params.${param.name}.str(),")
						}
					} else {
						sb.writeln("            \"${param.name}\": json.encode(params.${param.name}),")
					}
				}
				sb.writeln("        },")
			}
			sb.writeln("    }")
			sb.writeln("")

			if file_params.len > 0 || maybe_file_params.len > 0 {
				sb.writeln("    key := random_string(10)")
				sb.writeln("    form.files[key] = []")
			}

			if file_params.len > 0 {
				for param in file_params {
					sb.writeln("    form.files[key] << http.FileData{")
					sb.writeln("        filename: params.${param.name}.filename,")
					sb.writeln("        content_type: params.${param.name}.content_type,")
					sb.writeln("        data: params.${param.name}.data,")
					sb.writeln("    }")
					sb.writeln("")
				}
			}

			if maybe_file_params.len > 0 {
				for param in maybe_file_params {
					sb.writeln("    if params.${param.name} is InputFile {")
					sb.writeln("        form.files[key] << http.FileData{")
					sb.writeln("            filename: params.${param.name}.filename,")
					sb.writeln("            content_type: params.${param.name}.content_type,")
					sb.writeln("            data: params.${param.name}.data,")
					sb.writeln("        }")
					sb.writeln("    } else {")
					sb.writeln("        form.form[\"${param.name}\"] = params.${param.name} as string")
					sb.writeln("    }")
					sb.writeln("")
				}
			}

			sb.writeln("    mut raw_json := ctx.request_multipart(\"${func.method}\", form)!")
		} else {
			if func.params.len > 0 {
				sb.writeln("    mut body := json.encode(params)")
			} else {
				sb.writeln("    mut body := \"{}\"")
			}
			sb.writeln("    mut raw_json := ctx.request(\"${func.method}\", body)!")
		}
		sb.writeln("    res := json.decode(ApiResponse[${func.returns}], raw_json)!")
		sb.writeln("    return res.result")

		sb.writeln("}")
		sb.writeln("")
	}
}

fn main() {
	spec := fetch_spec()
	api := Api.from_spec(spec)

	mut sb := strings.new_builder(2048)
	write_header(mut sb)
	write_sum_types(mut sb, api.sum_types.values())
	write_interfaces(mut sb, api.interfaces.values())
	write_structs(mut sb, api.structs)
	write_functions(mut sb, api)

	mut file := os.open_file(output_file, "w") or { panic(err) }
	file.write_string(sb.str()) or { panic(err) }
	file.close()
}
