module main

import os
import json
import strings
import net.http

const (
	output_file   = os.abs_path(os.join_path(os.getwd(), "src", "generated.v"))
	api_json_endpoint = "https://raw.githubusercontent.com/PaulSonOfLars/telegram-bot-api-spec/master/api.min.json"

	banner = "// This file was auto-generated by generator.vsh. Do not edit manually."
)

fn fetch_spec() JsonSpec {
	res := http.get(api_json_endpoint) or { panic(err) }
	return json.decode(JsonSpec, res.body) or { panic(err) }
}

fn write_header(mut sb strings.Builder) {
	sb.writeln(banner)
	sb.writeln("module main")
	sb.writeln("")
	sb.writeln("import json")
	sb.writeln("")
}

fn write_sum_types(mut sb strings.Builder, sum_types []ApiSumType) {
	for @type in sum_types {
		sb.writeln("pub type ${@type.name} = ${@type.value}")
		sb.writeln("")
	}
}

fn write_interfaces(mut sb strings.Builder, interfaces []ApiInterface) {
	for @interface in interfaces {
		for line in @interface.description {
			sb.writeln("// ${line}")
		}
		sb.writeln("pub type ${@interface.name} = ${@interface.structs.join(" | ")}")
		sb.writeln("")
	}
}

fn write_structs(mut sb strings.Builder, structs []ApiStruct) {
	for @struct in structs {
		if @struct.name in overridden_types {
			continue
		}

		for line in @struct.description {
			sb.writeln("// ${line}")
		}

		if @struct.fields.len > 0 {
			sb.writeln("pub struct ${@struct.name} {")
			sb.writeln("pub:")
			for field in @struct.fields {
				sb.write_string("    ${field.name} ")
				if !field.is_primitive() {
					sb.write_string("&")
				}
				sb.write_string(field.@type)
				if @struct.name in defaults {
					if field.name in defaults[@struct.name] {
						sb.write_string(" = ${defaults[@struct.name][field.name]}")
					}
				}
				sb.writeln("")
			}
			sb.writeln("}")
		} else {
			sb.writeln("pub struct ${@struct.name} {}")
		}

		sb.writeln("")
	}
}

fn write_functions(mut sb strings.Builder, api Api) {
	for func in api.functions {
		params_struct_name := "${to_camel_case(func.name, true)}Params"

		// First generate a params struct
		if func.params.len > 0 {
			sb.writeln("// Params for the `${func.name}` function.")
			sb.writeln("pub struct ${params_struct_name} {")
			sb.writeln("pub mut:")
			for param in func.params {
				sb.write_string("    ${param.name} ")
				if param.@type in api.sum_types {
					if api.sum_types[param.@type].array_of {
						sb.write_string("[]")
					}
				}
				sb.write_string("${param.@type}")
				if param.required {
					sb.write_string(" [required]")
				}
				sb.write_string("\n")
			}
			sb.writeln("}")
			sb.writeln("")
		}

		// Write out the comment
		for line in func.description {
			sb.writeln("// ${line}")
		}

		// Write out the function itself
		if func.params.len > 0 {
			sb.writeln("pub fn (ctx Context) ${func.name}(params $params_struct_name) !${func.returns} {")
		} else {
			sb.writeln("pub fn (ctx Context) ${func.name}() !${func.returns} {")
		}

		multipart := func.params.any(fn (param ApiField) bool {
			return param.@type.contains("InputFile")
		})

		if multipart {
			sb.writeln("    mut raw_json := ctx.request_multipart(\"${func.method}\", params)!")
		} else {
			if func.params.len > 0 {
				sb.writeln("    mut body := json.encode(params)")
			} else {
				sb.writeln("    mut body := \"{}\"")
			}
			sb.writeln("    mut raw_json := ctx.request(\"${func.method}\", body)!")
		}
		sb.writeln("    res := json.decode(ApiResponse[${func.returns}], raw_json)!")
		sb.writeln("    return res.result")

		sb.writeln("}")
		sb.writeln("")
	}
}

fn main() {
	spec := fetch_spec()
	api := Api.from_spec(spec)

	mut sb := strings.new_builder(2048)
	write_header(mut sb)
	write_sum_types(mut sb, api.sum_types.values())
	write_interfaces(mut sb, api.interfaces.values())
	write_structs(mut sb, api.structs)
	write_functions(mut sb, api)

	mut file := os.open_file(output_file, "w") or { panic(err) }
	file.write_string(sb.str()) or { panic(err) }
	file.close()
}
