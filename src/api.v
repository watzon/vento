// This file was auto-generated by generator.vsh. Do not edit manually.
module main

import json
import net.http

pub type IntegerOrString = i64 | string

pub type InputFileOrString = InputFile | string

pub type InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply = InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply

pub type InputMediaAudioOrInputMediaDocumentOrInputMediaPhotoOrInputMediaVideo = InputMediaAudio | InputMediaDocument | InputMediaPhoto | InputMediaVideo

pub type MessageOrBoolean = Message | bool

// This object contains information about one member of a chat. Currently, the following 6 types of chat members are
// supported:
// - ChatMemberOwner
// - ChatMemberAdministrator
// - ChatMemberMember
// - ChatMemberRestricted
// - ChatMemberLeft
// - ChatMemberBanned
pub type ChatMember = ChatMemberOwner | ChatMemberAdministrator | ChatMemberMember | ChatMemberRestricted | ChatMemberLeft | ChatMemberBanned

// This object represents the scope to which bot commands are applied. Currently, the following 7 scopes are supported:
// - BotCommandScopeDefault
// - BotCommandScopeAllPrivateChats
// - BotCommandScopeAllGroupChats
// - BotCommandScopeAllChatAdministrators
// - BotCommandScopeChat
// - BotCommandScopeChatAdministrators
// - BotCommandScopeChatMember
pub type BotCommandScope = BotCommandScopeDefault | BotCommandScopeAllPrivateChats | BotCommandScopeAllGroupChats | BotCommandScopeAllChatAdministrators | BotCommandScopeChat | BotCommandScopeChatAdministrators | BotCommandScopeChatMember

// This object describes the bot's menu button in a private chat. It should be one of
// - MenuButtonCommands
// - MenuButtonWebApp
// - MenuButtonDefault
// If a menu button other than MenuButtonDefault is set for a private chat, then it is applied in the chat. Otherwise the
// default menu button is applied. By default, the menu button opens the list of bot commands.
pub type MenuButton = MenuButtonCommands | MenuButtonWebApp | MenuButtonDefault

// This object represents the content of a media message to be sent. It should be one of
// - InputMediaAnimation
// - InputMediaDocument
// - InputMediaAudio
// - InputMediaPhoto
// - InputMediaVideo
pub type InputMedia = InputMediaPhoto | InputMediaVideo | InputMediaAnimation | InputMediaAudio | InputMediaDocument

// This object represents one result of an inline query. Telegram clients currently support results of the following 20
// types:
// - InlineQueryResultCachedAudio
// - InlineQueryResultCachedDocument
// - InlineQueryResultCachedGif
// - InlineQueryResultCachedMpeg4Gif
// - InlineQueryResultCachedPhoto
// - InlineQueryResultCachedSticker
// - InlineQueryResultCachedVideo
// - InlineQueryResultCachedVoice
// - InlineQueryResultArticle
// - InlineQueryResultAudio
// - InlineQueryResultContact
// - InlineQueryResultGame
// - InlineQueryResultDocument
// - InlineQueryResultGif
// - InlineQueryResultLocation
// - InlineQueryResultMpeg4Gif
// - InlineQueryResultPhoto
// - InlineQueryResultVenue
// - InlineQueryResultVideo
// - InlineQueryResultVoice
// Note: All URLs passed in inline query results will be available to end users and therefore must be assumed to be
// public.
pub type InlineQueryResult = InlineQueryResultArticle | InlineQueryResultPhoto | InlineQueryResultGif | InlineQueryResultMpeg4Gif | InlineQueryResultVideo | InlineQueryResultAudio | InlineQueryResultVoice | InlineQueryResultDocument | InlineQueryResultLocation | InlineQueryResultVenue | InlineQueryResultContact | InlineQueryResultGame | InlineQueryResultCachedPhoto | InlineQueryResultCachedGif | InlineQueryResultCachedMpeg4Gif | InlineQueryResultCachedSticker | InlineQueryResultCachedDocument | InlineQueryResultCachedVideo | InlineQueryResultCachedVoice | InlineQueryResultCachedAudio

// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently
// support the following 5 types:
// - InputTextMessageContent
// - InputLocationMessageContent
// - InputVenueMessageContent
// - InputContactMessageContent
// - InputInvoiceMessageContent
pub type InputMessageContent = InputTextMessageContent | InputLocationMessageContent | InputVenueMessageContent | InputContactMessageContent | InputInvoiceMessageContent

// This object represents an error in the Telegram Passport element which was submitted that should be resolved by the
// user. It should be one of:
// - PassportElementErrorDataField
// - PassportElementErrorFrontSide
// - PassportElementErrorReverseSide
// - PassportElementErrorSelfie
// - PassportElementErrorFile
// - PassportElementErrorFiles
// - PassportElementErrorTranslationFile
// - PassportElementErrorTranslationFiles
// - PassportElementErrorUnspecified
pub type PassportElementError = PassportElementErrorDataField | PassportElementErrorFrontSide | PassportElementErrorReverseSide | PassportElementErrorSelfie | PassportElementErrorFile | PassportElementErrorFiles | PassportElementErrorTranslationFile | PassportElementErrorTranslationFiles | PassportElementErrorUnspecified

// This object represents an incoming update.
// At most one of the optional parameters can be present in any given update.
pub struct Update {
pub:
    update_id i64
    message ?&Message
    edited_message ?&Message
    channel_post ?&Message
    edited_channel_post ?&Message
    inline_query ?&InlineQuery
    chosen_inline_result ?&ChosenInlineResult
    callback_query ?&CallbackQuery
    shipping_query ?&ShippingQuery
    pre_checkout_query ?&PreCheckoutQuery
    poll ?&Poll
    poll_answer ?&PollAnswer
    my_chat_member ?&ChatMemberUpdated
    chat_member ?&ChatMemberUpdated
    chat_join_request ?&ChatJoinRequest
}

// Describes the current status of a webhook.
pub struct WebhookInfo {
pub:
    url string
    has_custom_certificate bool
    pending_update_count i64
    ip_address string
    last_error_date i64
    last_error_message string
    last_synchronization_error_date i64
    max_connections i64
    allowed_updates []string
}

// This object represents a Telegram user or bot.
pub struct User {
pub:
    id i64
    is_bot bool
    first_name string
    last_name string
    username string
    language_code string
    is_premium bool
    added_to_attachment_menu bool
    can_join_groups bool
    can_read_all_group_messages bool
    supports_inline_queries bool
}

// This object represents a chat.
pub struct Chat {
pub:
    id i64
    @type string
    title string
    username string
    first_name string
    last_name string
    is_forum bool
    photo ?&ChatPhoto
    active_usernames []string
    emoji_status_custom_emoji_id string
    bio string
    has_private_forwards bool
    has_restricted_voice_and_video_messages bool
    join_to_send_messages bool
    join_by_request bool
    description string
    invite_link string
    pinned_message ?&Message
    permissions ?&ChatPermissions
    slow_mode_delay i64
    message_auto_delete_time i64
    has_aggressive_anti_spam_enabled bool
    has_hidden_members bool
    has_protected_content bool
    sticker_set_name string
    can_set_sticker_set bool
    linked_chat_id i64
    location ?&ChatLocation
}

// This object represents a message.
pub struct Message {
pub:
    message_id i64
    message_thread_id i64
    from ?&User
    sender_chat ?&Chat
    date i64
    chat &Chat
    forward_from ?&User
    forward_from_chat ?&Chat
    forward_from_message_id i64
    forward_signature string
    forward_sender_name string
    forward_date i64
    is_topic_message bool
    is_automatic_forward bool
    reply_to_message ?&Message
    via_bot ?&User
    edit_date i64
    has_protected_content bool
    media_group_id string
    author_signature string
    text string
    entities []MessageEntity
    animation ?&Animation
    audio ?&Audio
    document ?&Document
    photo []PhotoSize
    sticker ?&Sticker
    video ?&Video
    video_note ?&VideoNote
    voice ?&Voice
    caption string
    caption_entities []MessageEntity
    has_media_spoiler bool
    contact ?&Contact
    dice ?&Dice
    game ?&Game
    poll ?&Poll
    venue ?&Venue
    location ?&Location
    new_chat_members []User
    left_chat_member ?&User
    new_chat_title string
    new_chat_photo []PhotoSize
    delete_chat_photo bool
    group_chat_created bool
    supergroup_chat_created bool
    channel_chat_created bool
    message_auto_delete_timer_changed ?&MessageAutoDeleteTimerChanged
    migrate_to_chat_id i64
    migrate_from_chat_id i64
    pinned_message ?&Message
    invoice ?&Invoice
    successful_payment ?&SuccessfulPayment
    user_shared ?&UserShared
    chat_shared ?&ChatShared
    connected_website string
    write_access_allowed ?&WriteAccessAllowed
    passport_data ?&PassportData
    proximity_alert_triggered ?&ProximityAlertTriggered
    forum_topic_created ?&ForumTopicCreated
    forum_topic_edited ?&ForumTopicEdited
    forum_topic_closed ?&ForumTopicClosed
    forum_topic_reopened ?&ForumTopicReopened
    general_forum_topic_hidden ?&GeneralForumTopicHidden
    general_forum_topic_unhidden ?&GeneralForumTopicUnhidden
    video_chat_scheduled ?&VideoChatScheduled
    video_chat_started ?&VideoChatStarted
    video_chat_ended ?&VideoChatEnded
    video_chat_participants_invited ?&VideoChatParticipantsInvited
    web_app_data ?&WebAppData
    reply_markup ?&InlineKeyboardMarkup
}

// This object represents a unique message identifier.
pub struct MessageId {
pub:
    message_id i64
}

// This object represents one special entity in a text message. For example, hashtags, usernames, URLs, etc.
pub struct MessageEntity {
pub:
    @type string
    offset i64
    length i64
    url string
    user ?&User
    language string
    custom_emoji_id string
}

// This object represents one size of a photo or a file / sticker thumbnail.
pub struct PhotoSize {
pub:
    file_id string
    file_unique_id string
    width i64
    height i64
    file_size i64
}

// This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
pub struct Animation {
pub:
    file_id string
    file_unique_id string
    width i64
    height i64
    duration i64
    thumbnail ?&PhotoSize
    file_name string
    mime_type string
    file_size i64
}

// This object represents an audio file to be treated as music by the Telegram clients.
pub struct Audio {
pub:
    file_id string
    file_unique_id string
    duration i64
    performer string
    title string
    file_name string
    mime_type string
    file_size i64
    thumbnail ?&PhotoSize
}

// This object represents a general file (as opposed to photos, voice messages and audio files).
pub struct Document {
pub:
    file_id string
    file_unique_id string
    thumbnail ?&PhotoSize
    file_name string
    mime_type string
    file_size i64
}

// This object represents a video file.
pub struct Video {
pub:
    file_id string
    file_unique_id string
    width i64
    height i64
    duration i64
    thumbnail ?&PhotoSize
    file_name string
    mime_type string
    file_size i64
}

// This object represents a video message (available in Telegram apps as of v.4.0).
pub struct VideoNote {
pub:
    file_id string
    file_unique_id string
    length i64
    duration i64
    thumbnail ?&PhotoSize
    file_size i64
}

// This object represents a voice note.
pub struct Voice {
pub:
    file_id string
    file_unique_id string
    duration i64
    mime_type string
    file_size i64
}

// This object represents a phone contact.
pub struct Contact {
pub:
    phone_number string
    first_name string
    last_name string
    user_id i64
    vcard string
}

// This object represents an animated emoji that displays a random value.
pub struct Dice {
pub:
    emoji string
    value i64
}

// This object contains information about one answer option in a poll.
pub struct PollOption {
pub:
    text string
    voter_count i64
}

// This object represents an answer of a user in a non-anonymous poll.
pub struct PollAnswer {
pub:
    poll_id string
    user &User
    option_ids []i64
}

// This object contains information about a poll.
pub struct Poll {
pub:
    id string
    question string
    options []PollOption
    total_voter_count i64
    is_closed bool
    is_anonymous bool
    @type string
    allows_multiple_answers bool
    correct_option_id i64
    explanation string
    explanation_entities []MessageEntity
    open_period i64
    close_date i64
}

// This object represents a point on the map.
pub struct Location {
pub:
    longitude f64
    latitude f64
    horizontal_accuracy f64
    live_period i64
    heading i64
    proximity_alert_radius i64
}

// This object represents a venue.
pub struct Venue {
pub:
    location &Location
    title string
    address string
    foursquare_id string
    foursquare_type string
    google_place_id string
    google_place_type string
}

// Describes data sent from a Web App to the bot.
pub struct WebAppData {
pub:
    data string
    button_text string
}

// This object represents the content of a service message, sent whenever a user in the chat triggers a proximity alert
// set by another user.
pub struct ProximityAlertTriggered {
pub:
    traveler &User
    watcher &User
    distance i64
}

// This object represents a service message about a change in auto-delete timer settings.
pub struct MessageAutoDeleteTimerChanged {
pub:
    message_auto_delete_time i64
}

// This object represents a service message about a new forum topic created in the chat.
pub struct ForumTopicCreated {
pub:
    name string
    icon_color i64
    icon_custom_emoji_id string
}

// This object represents a service message about a forum topic closed in the chat. Currently holds no information.
pub struct ForumTopicClosed {}

// This object represents a service message about an edited forum topic.
pub struct ForumTopicEdited {
pub:
    name string
    icon_custom_emoji_id string
}

// This object represents a service message about a forum topic reopened in the chat. Currently holds no information.
pub struct ForumTopicReopened {}

// This object represents a service message about General forum topic hidden in the chat. Currently holds no information.
pub struct GeneralForumTopicHidden {}

// This object represents a service message about General forum topic unhidden in the chat. Currently holds no
// information.
pub struct GeneralForumTopicUnhidden {}

// This object contains information about the user whose identifier was shared with the bot using a
// KeyboardButtonRequestUser button.
pub struct UserShared {
pub:
    request_id i64
    user_id i64
}

// This object contains information about the chat whose identifier was shared with the bot using a
// KeyboardButtonRequestChat button.
pub struct ChatShared {
pub:
    request_id i64
    chat_id i64
}

// This object represents a service message about a user allowing a bot to write messages after adding the bot to the
// attachment menu or launching a Web App from a link.
pub struct WriteAccessAllowed {
pub:
    web_app_name string
}

// This object represents a service message about a video chat scheduled in the chat.
pub struct VideoChatScheduled {
pub:
    start_date i64
}

// This object represents a service message about a video chat started in the chat. Currently holds no information.
pub struct VideoChatStarted {}

// This object represents a service message about a video chat ended in the chat.
pub struct VideoChatEnded {
pub:
    duration i64
}

// This object represents a service message about new members invited to a video chat.
pub struct VideoChatParticipantsInvited {
pub:
    users []User
}

// This object represent a user's profile pictures.
pub struct UserProfilePhotos {
pub:
    total_count i64
    photos [][]PhotoSize
}

// This object represents a file ready to be downloaded. The file can be downloaded via the link
// https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be
// valid for at least 1 hour. When the link expires, a new one can be requested by calling
// getFile.
pub struct File {
pub:
    file_id string
    file_unique_id string
    file_size i64
    file_path string
}

// Describes a Web App.
pub struct WebAppInfo {
pub:
    url string
}

// This object represents a custom keyboard with reply options (see Introduction to bots for details and examples).
pub struct ReplyKeyboardMarkup {
pub:
    keyboard [][]KeyboardButton
    is_persistent bool
    resize_keyboard bool
    one_time_keyboard bool
    input_field_placeholder string
    selective bool
}

// This object represents one button of the reply keyboard. For simple text buttons, String can be used instead of this
// object to specify the button text. The optional fields web_app, request_user, request_chat, request_contact,
// request_location, and request_poll are mutually exclusive.
// Note: request_contact and request_location options will only work in Telegram versions released after 9 April, 2016.
// Older clients will display unsupported message.
// Note: request_poll option will only work in Telegram versions released after 23 January, 2020. Older clients will
// display unsupported message.
// Note: web_app option will only work in Telegram versions released after 16 April, 2022. Older clients will display
// unsupported message.
// Note: request_user and request_chat options will only work in Telegram versions released after 3 February, 2023. Older
// clients will display unsupported message.
pub struct KeyboardButton {
pub:
    text string
    request_user ?&KeyboardButtonRequestUser
    request_chat ?&KeyboardButtonRequestChat
    request_contact bool
    request_location bool
    request_poll ?&KeyboardButtonPollType
    web_app ?&WebAppInfo
}

// This object defines the criteria used to request a suitable user. The identifier of the selected user will be shared
// with the bot when the corresponding button is pressed. More about requesting users:
// https://core.telegram.org/bots/features#chat-and-user-selection
pub struct KeyboardButtonRequestUser {
pub:
    request_id i64
    user_is_bot bool
    user_is_premium bool
}

// This object defines the criteria used to request a suitable chat. The identifier of the selected chat will be shared
// with the bot when the corresponding button is pressed. More about requesting chats:
// https://core.telegram.org/bots/features#chat-and-user-selection
pub struct KeyboardButtonRequestChat {
pub:
    request_id i64
    chat_is_channel bool
    chat_is_forum bool
    chat_has_username bool
    chat_is_created bool
    user_administrator_rights ?&ChatAdministratorRights
    bot_administrator_rights ?&ChatAdministratorRights
    bot_is_member bool
}

// This object represents type of a poll, which is allowed to be created and sent when the corresponding button is
// pressed.
pub struct KeyboardButtonPollType {
pub:
    @type string
}

// Upon receiving a message with this object, Telegram clients will remove the current custom keyboard and display the
// default letter-keyboard. By default, custom keyboards are displayed until a new keyboard is sent by a bot. An
// exception is made for one-time keyboards that are hidden immediately after the user presses a button (see
// ReplyKeyboardMarkup).
pub struct ReplyKeyboardRemove {
pub:
    remove_keyboard bool
    selective bool
}

// This object represents an inline keyboard that appears right next to the message it belongs to.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported
// message.
pub struct InlineKeyboardMarkup {
pub:
    inline_keyboard [][]InlineKeyboardButton
}

// This object represents one button of an inline keyboard. You must use exactly one of the optional fields.
pub struct InlineKeyboardButton {
pub:
    text string
    url string
    callback_data string
    web_app ?&WebAppInfo
    login_url ?&LoginUrl
    switch_inline_query string
    switch_inline_query_current_chat string
    switch_inline_query_chosen_chat ?&SwitchInlineQueryChosenChat
    callback_game ?&CallbackGame
    pay bool
}

// This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a
// great replacement for the Telegram Login Widget when the user is coming from Telegram. All the user needs to do is
// tap/click a button and confirm that they want to log in:
// Telegram apps support these buttons as of version 5.7.
pub struct LoginUrl {
pub:
    url string
    forward_text string
    bot_username string
    request_write_access bool
}

// This object represents an inline button that switches the current user to inline mode in a chosen chat, with an
// optional default inline query.
pub struct SwitchInlineQueryChosenChat {
pub:
    query string
    allow_user_chats bool
    allow_bot_chats bool
    allow_group_chats bool
    allow_channel_chats bool
}

// This object represents an incoming callback query from a callback button in an inline keyboard. If the button that
// originated the query was attached to a message sent by the bot, the field message will be present. If the button
// was attached to a message sent via the bot (in inline mode), the field inline_message_id will be present.
// Exactly one of the fields data or game_short_name will be present.
pub struct CallbackQuery {
pub:
    id string
    from &User
    message ?&Message
    inline_message_id string
    chat_instance string
    data string
    game_short_name string
}

// Upon receiving a message with this object, Telegram clients will display a reply interface to the user (act as if the
// user has selected the bot's message and tapped 'Reply'). This can be extremely useful if you want to create
// user-friendly step-by-step interfaces without having to sacrifice privacy mode.
pub struct ForceReply {
pub:
    force_reply bool
    input_field_placeholder string
    selective bool
}

// This object represents a chat photo.
pub struct ChatPhoto {
pub:
    small_file_id string
    small_file_unique_id string
    big_file_id string
    big_file_unique_id string
}

// Represents an invite link for a chat.
pub struct ChatInviteLink {
pub:
    invite_link string
    creator &User
    creates_join_request bool
    is_primary bool
    is_revoked bool
    name string
    expire_date i64
    member_limit i64
    pending_join_request_count i64
}

// Represents the rights of an administrator in a chat.
pub struct ChatAdministratorRights {
pub:
    is_anonymous bool
    can_manage_chat bool
    can_delete_messages bool
    can_manage_video_chats bool
    can_restrict_members bool
    can_promote_members bool
    can_change_info bool
    can_invite_users bool
    can_post_messages bool
    can_edit_messages bool
    can_pin_messages bool
    can_manage_topics bool
}

// Represents a chat member that owns the chat and has all administrator privileges.
pub struct ChatMemberOwner {
pub:
    status string
    user &User
    is_anonymous bool
    custom_title string
}

// Represents a chat member that has some additional privileges.
pub struct ChatMemberAdministrator {
pub:
    status string
    user &User
    can_be_edited bool
    is_anonymous bool
    can_manage_chat bool
    can_delete_messages bool
    can_manage_video_chats bool
    can_restrict_members bool
    can_promote_members bool
    can_change_info bool
    can_invite_users bool
    can_post_messages bool
    can_edit_messages bool
    can_pin_messages bool
    can_manage_topics bool
    custom_title string
}

// Represents a chat member that has no additional privileges or restrictions.
pub struct ChatMemberMember {
pub:
    status string
    user &User
}

// Represents a chat member that is under certain restrictions in the chat. Supergroups only.
pub struct ChatMemberRestricted {
pub:
    status string
    user &User
    is_member bool
    can_send_messages bool
    can_send_audios bool
    can_send_documents bool
    can_send_photos bool
    can_send_videos bool
    can_send_video_notes bool
    can_send_voice_notes bool
    can_send_polls bool
    can_send_other_messages bool
    can_add_web_page_previews bool
    can_change_info bool
    can_invite_users bool
    can_pin_messages bool
    can_manage_topics bool
    until_date i64
}

// Represents a chat member that isn't currently a member of the chat, but may join it themselves.
pub struct ChatMemberLeft {
pub:
    status string
    user &User
}

// Represents a chat member that was banned in the chat and can't return to the chat or view chat messages.
pub struct ChatMemberBanned {
pub:
    status string
    user &User
    until_date i64
}

// This object represents changes in the status of a chat member.
pub struct ChatMemberUpdated {
pub:
    chat &Chat
    from &User
    date i64
    old_chat_member &ChatMember
    new_chat_member &ChatMember
    invite_link ?&ChatInviteLink
    via_chat_folder_invite_link bool
}

// Represents a join request sent to a chat.
pub struct ChatJoinRequest {
pub:
    chat &Chat
    from &User
    user_chat_id i64
    date i64
    bio string
    invite_link ?&ChatInviteLink
}

// Describes actions that a non-administrator user is allowed to take in a chat.
pub struct ChatPermissions {
pub:
    can_send_messages bool
    can_send_audios bool
    can_send_documents bool
    can_send_photos bool
    can_send_videos bool
    can_send_video_notes bool
    can_send_voice_notes bool
    can_send_polls bool
    can_send_other_messages bool
    can_add_web_page_previews bool
    can_change_info bool
    can_invite_users bool
    can_pin_messages bool
    can_manage_topics bool
}

// Represents a location to which a chat is connected.
pub struct ChatLocation {
pub:
    location &Location
    address string
}

// This object represents a forum topic.
pub struct ForumTopic {
pub:
    message_thread_id i64
    name string
    icon_color i64
    icon_custom_emoji_id string
}

// This object represents a bot command.
pub struct BotCommand {
pub:
    command string
    description string
}

// Represents the default scope of bot commands. Default commands are used if no commands with a narrower scope are
// specified for the user.
pub struct BotCommandScopeDefault {
pub:
    @type string
}

// Represents the scope of bot commands, covering all private chats.
pub struct BotCommandScopeAllPrivateChats {
pub:
    @type string
}

// Represents the scope of bot commands, covering all group and supergroup chats.
pub struct BotCommandScopeAllGroupChats {
pub:
    @type string
}

// Represents the scope of bot commands, covering all group and supergroup chat administrators.
pub struct BotCommandScopeAllChatAdministrators {
pub:
    @type string
}

// Represents the scope of bot commands, covering a specific chat.
pub struct BotCommandScopeChat {
pub:
    @type string
    chat_id &IntegerOrString
}

// Represents the scope of bot commands, covering all administrators of a specific group or supergroup chat.
pub struct BotCommandScopeChatAdministrators {
pub:
    @type string
    chat_id &IntegerOrString
}

// Represents the scope of bot commands, covering a specific member of a group or supergroup chat.
pub struct BotCommandScopeChatMember {
pub:
    @type string
    chat_id &IntegerOrString
    user_id i64
}

// This object represents the bot's name.
pub struct BotName {
pub:
    name string
}

// This object represents the bot's description.
pub struct BotDescription {
pub:
    description string
}

// This object represents the bot's short description.
pub struct BotShortDescription {
pub:
    short_description string
}

// Represents a menu button, which opens the bot's list of commands.
pub struct MenuButtonCommands {
pub:
    @type string
}

// Represents a menu button, which launches a Web App.
pub struct MenuButtonWebApp {
pub:
    @type string
    text string
    web_app &WebAppInfo
}

// Describes that no specific value for the menu button was set.
pub struct MenuButtonDefault {
pub:
    @type string
}

// Describes why a request was unsuccessful.
pub struct ResponseParameters {
pub:
    migrate_to_chat_id i64
    retry_after i64
}

// Represents a photo to be sent.
pub struct InputMediaPhoto {
pub:
    @type string = 'photo'
    media string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    has_spoiler bool
}

// Represents a video to be sent.
pub struct InputMediaVideo {
pub:
    @type string = 'video'
    media string
    thumbnail ?&InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    width i64
    height i64
    duration i64
    supports_streaming bool
    has_spoiler bool
}

// Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent.
pub struct InputMediaAnimation {
pub:
    @type string = 'animation'
    media string
    thumbnail ?&InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    width i64
    height i64
    duration i64
    has_spoiler bool
}

// Represents an audio file to be treated as music to be sent.
pub struct InputMediaAudio {
pub:
    @type string = 'audio'
    media string
    thumbnail ?&InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    duration i64
    performer string
    title string
}

// Represents a general file to be sent.
pub struct InputMediaDocument {
pub:
    @type string = 'document'
    media string
    thumbnail ?&InputFileOrString
    caption string
    parse_mode string
    caption_entities []MessageEntity
    disable_content_type_detection bool
}

// This object represents a sticker.
pub struct Sticker {
pub:
    file_id string
    file_unique_id string
    @type string
    width i64
    height i64
    is_animated bool
    is_video bool
    thumbnail ?&PhotoSize
    emoji string
    set_name string
    premium_animation ?&File
    mask_position ?&MaskPosition
    custom_emoji_id string
    needs_repainting bool
    file_size i64
}

// This object represents a sticker set.
pub struct StickerSet {
pub:
    name string
    title string
    sticker_type string
    is_animated bool
    is_video bool
    stickers []Sticker
    thumbnail ?&PhotoSize
}

// This object describes the position on faces where a mask should be placed by default.
pub struct MaskPosition {
pub:
    point string
    x_shift f64
    y_shift f64
    scale f64
}

// This object describes a sticker to be added to a sticker set.
pub struct InputSticker {
pub:
    sticker &InputFileOrString
    emoji_list []string
    mask_position ?&MaskPosition
    keywords []string
}

// This object represents an incoming inline query. When the user sends an empty query, your bot could return some default
// or trending results.
pub struct InlineQuery {
pub:
    id string
    from &User
    query string
    offset string
    chat_type string
    location ?&Location
}

// This object represents a button to be shown above inline query results. You must use exactly one of the optional
// fields.
pub struct InlineQueryResultsButton {
pub:
    text string
    web_app ?&WebAppInfo
    start_parameter string
}

// Represents a link to an article or web page.
pub struct InlineQueryResultArticle {
pub:
    @type string = 'article'
    id string
    title string
    input_message_content &InputMessageContent
    reply_markup ?&InlineKeyboardMarkup
    url string
    hide_url bool
    description string
    thumbnail_url string
    thumbnail_width i64
    thumbnail_height i64
}

// Represents a link to a photo. By default, this photo will be sent by the user with optional caption. Alternatively, you
// can use input_message_content to send a message with the specified content instead of the photo.
pub struct InlineQueryResultPhoto {
pub:
    @type string = 'photo'
    id string
    photo_url string
    thumbnail_url string
    photo_width i64
    photo_height i64
    title string
    description string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to an animated GIF file. By default, this animated GIF file will be sent by the user with optional
// caption. Alternatively, you can use input_message_content to send a message with the specified content instead of
// the animation.
pub struct InlineQueryResultGif {
pub:
    @type string = 'gif'
    id string
    gif_url string
    gif_width i64
    gif_height i64
    gif_duration i64
    thumbnail_url string
    thumbnail_mime_type string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this animated MPEG-4 file
// will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message
// with the specified content instead of the animation.
pub struct InlineQueryResultMpeg4Gif {
pub:
    @type string = 'mpeg4_gif'
    id string
    mpeg4_url string
    mpeg4_width i64
    mpeg4_height i64
    mpeg4_duration i64
    thumbnail_url string
    thumbnail_mime_type string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to a page containing an embedded video player or a video file. By default, this video file will be
// sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with
// the specified content instead of the video.
pub struct InlineQueryResultVideo {
pub:
    @type string = 'video'
    id string
    video_url string
    mime_type string
    thumbnail_url string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    video_width i64
    video_height i64
    video_duration i64
    description string
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to an MP3 audio file. By default, this audio file will be sent by the user. Alternatively, you can
// use input_message_content to send a message with the specified content instead of the audio.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultAudio {
pub:
    @type string = 'audio'
    id string
    audio_url string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    performer string
    audio_duration i64
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to a voice recording in an .OGG container encoded with OPUS. By default, this voice recording will be
// sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead
// of the the voice message.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultVoice {
pub:
    @type string = 'voice'
    id string
    voice_url string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    voice_duration i64
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to a file. By default, this file will be sent by the user with an optional caption. Alternatively,
// you can use input_message_content to send a message with the specified content instead of the file. Currently, only
// .PDF and .ZIP files can be sent using this method.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultDocument {
pub:
    @type string = 'document'
    id string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    document_url string
    mime_type string
    description string
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
    thumbnail_url string
    thumbnail_width i64
    thumbnail_height i64
}

// Represents a location on a map. By default, the location will be sent by the user. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the location.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultLocation {
pub:
    @type string = 'location'
    id string
    latitude f64
    longitude f64
    title string
    horizontal_accuracy f64
    live_period i64
    heading i64
    proximity_alert_radius i64
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
    thumbnail_url string
    thumbnail_width i64
    thumbnail_height i64
}

// Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use input_message_content to
// send a message with the specified content instead of the venue.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultVenue {
pub:
    @type string = 'venue'
    id string
    latitude f64
    longitude f64
    title string
    address string
    foursquare_id string
    foursquare_type string
    google_place_id string
    google_place_type string
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
    thumbnail_url string
    thumbnail_width i64
    thumbnail_height i64
}

// Represents a contact with a phone number. By default, this contact will be sent by the user. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the contact.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultContact {
pub:
    @type string = 'contact'
    id string
    phone_number string
    first_name string
    last_name string
    vcard string
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
    thumbnail_url string
    thumbnail_width i64
    thumbnail_height i64
}

// Represents a Game.
// Note: This will only work in Telegram versions released after October 1, 2016. Older clients will not display any
// inline results if a game result is among them.
pub struct InlineQueryResultGame {
pub:
    @type string = 'game'
    id string
    game_short_name string
    reply_markup ?&InlineKeyboardMarkup
}

// Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent by the user with an
// optional caption. Alternatively, you can use input_message_content to send a message with the specified content
// instead of the photo.
pub struct InlineQueryResultCachedPhoto {
pub:
    @type string = 'photo'
    id string
    photo_file_id string
    title string
    description string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to an animated GIF file stored on the Telegram servers. By default, this animated GIF file will be
// sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with
// specified content instead of the animation.
pub struct InlineQueryResultCachedGif {
pub:
    @type string = 'gif'
    id string
    gif_file_id string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the Telegram servers. By
// default, this animated MPEG-4 file will be sent by the user with an optional caption. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the animation.
pub struct InlineQueryResultCachedMpeg4Gif {
pub:
    @type string = 'mpeg4_gif'
    id string
    mpeg4_file_id string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be sent by the user.
// Alternatively, you can use input_message_content to send a message with the specified content instead of the
// sticker.
// Note: This will only work in Telegram versions released after 9 April, 2016 for static stickers and after 06 July, 2019
// for animated stickers. Older clients will ignore them.
pub struct InlineQueryResultCachedSticker {
pub:
    @type string = 'sticker'
    id string
    sticker_file_id string
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to a file stored on the Telegram servers. By default, this file will be sent by the user with an
// optional caption. Alternatively, you can use input_message_content to send a message with the specified content
// instead of the file.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultCachedDocument {
pub:
    @type string = 'document'
    id string
    title string
    document_file_id string
    description string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to a video file stored on the Telegram servers. By default, this video file will be sent by the user
// with an optional caption. Alternatively, you can use input_message_content to send a message with the specified
// content instead of the video.
pub struct InlineQueryResultCachedVideo {
pub:
    @type string = 'video'
    id string
    video_file_id string
    title string
    description string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to a voice message stored on the Telegram servers. By default, this voice message will be sent by the
// user. Alternatively, you can use input_message_content to send a message with the specified content instead of the
// voice message.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultCachedVoice {
pub:
    @type string = 'voice'
    id string
    voice_file_id string
    title string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents a link to an MP3 audio file stored on the Telegram servers. By default, this audio file will be sent by the
// user. Alternatively, you can use input_message_content to send a message with the specified content instead of the
// audio.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
pub struct InlineQueryResultCachedAudio {
pub:
    @type string = 'audio'
    id string
    audio_file_id string
    caption string
    parse_mode string
    caption_entities []MessageEntity
    reply_markup ?&InlineKeyboardMarkup
    input_message_content ?&InputMessageContent
}

// Represents the content of a text message to be sent as the result of an inline query.
pub struct InputTextMessageContent {
pub:
    message_text string
    parse_mode string
    entities []MessageEntity
    disable_web_page_preview bool
}

// Represents the content of a location message to be sent as the result of an inline query.
pub struct InputLocationMessageContent {
pub:
    latitude f64
    longitude f64
    horizontal_accuracy f64
    live_period i64
    heading i64
    proximity_alert_radius i64
}

// Represents the content of a venue message to be sent as the result of an inline query.
pub struct InputVenueMessageContent {
pub:
    latitude f64
    longitude f64
    title string
    address string
    foursquare_id string
    foursquare_type string
    google_place_id string
    google_place_type string
}

// Represents the content of a contact message to be sent as the result of an inline query.
pub struct InputContactMessageContent {
pub:
    phone_number string
    first_name string
    last_name string
    vcard string
}

// Represents the content of an invoice message to be sent as the result of an inline query.
pub struct InputInvoiceMessageContent {
pub:
    title string
    description string
    payload string
    provider_token string
    currency string
    prices []LabeledPrice
    max_tip_amount i64
    suggested_tip_amounts []i64
    provider_data string
    photo_url string
    photo_size i64
    photo_width i64
    photo_height i64
    need_name bool
    need_phone_number bool
    need_email bool
    need_shipping_address bool
    send_phone_number_to_provider bool
    send_email_to_provider bool
    is_flexible bool
}

// Represents a result of an inline query that was chosen by the user and sent to their chat partner.
// Note: It is necessary to enable inline feedback via @BotFather in order to receive these objects in updates.
pub struct ChosenInlineResult {
pub:
    result_id string
    from &User
    location ?&Location
    inline_message_id string
    query string
}

// Describes an inline message sent by a Web App on behalf of a user.
pub struct SentWebAppMessage {
pub:
    inline_message_id string
}

// This object represents a portion of the price for goods or services.
pub struct LabeledPrice {
pub:
    label string
    amount i64
}

// This object contains basic information about an invoice.
pub struct Invoice {
pub:
    title string
    description string
    start_parameter string
    currency string
    total_amount i64
}

// This object represents a shipping address.
pub struct ShippingAddress {
pub:
    country_code string
    state string
    city string
    street_line1 string
    street_line2 string
    post_code string
}

// This object represents information about an order.
pub struct OrderInfo {
pub:
    name string
    phone_number string
    email string
    shipping_address ?&ShippingAddress
}

// This object represents one shipping option.
pub struct ShippingOption {
pub:
    id string
    title string
    prices []LabeledPrice
}

// This object contains basic information about a successful payment.
pub struct SuccessfulPayment {
pub:
    currency string
    total_amount i64
    invoice_payload string
    shipping_option_id string
    order_info ?&OrderInfo
    telegram_payment_charge_id string
    provider_payment_charge_id string
}

// This object contains information about an incoming shipping query.
pub struct ShippingQuery {
pub:
    id string
    from &User
    invoice_payload string
    shipping_address &ShippingAddress
}

// This object contains information about an incoming pre-checkout query.
pub struct PreCheckoutQuery {
pub:
    id string
    from &User
    currency string
    total_amount i64
    invoice_payload string
    shipping_option_id string
    order_info ?&OrderInfo
}

// Describes Telegram Passport data shared with the bot by the user.
pub struct PassportData {
pub:
    data []EncryptedPassportElement
    credentials &EncryptedCredentials
}

// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format
// when decrypted and don't exceed 10MB.
pub struct PassportFile {
pub:
    file_id string
    file_unique_id string
    file_size i64
    file_date i64
}

// Describes documents or other Telegram Passport elements shared with the bot by the user.
pub struct EncryptedPassportElement {
pub:
    @type string
    data string
    phone_number string
    email string
    files []PassportFile
    front_side ?&PassportFile
    reverse_side ?&PassportFile
    selfie ?&PassportFile
    translation []PassportFile
    hash string
}

// Describes data required for decrypting and authenticating EncryptedPassportElement. See the Telegram Passport
// Documentation for a complete description of the data decryption and authentication processes.
pub struct EncryptedCredentials {
pub:
    data string
    hash string
    secret string
}

// Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the
// field's value changes.
pub struct PassportElementErrorDataField {
pub:
    source string
    @type string
    field_name string
    data_hash string
    message string
}

// Represents an issue with the front side of a document. The error is considered resolved when the file with the front
// side of the document changes.
pub struct PassportElementErrorFrontSide {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse
// side of the document changes.
pub struct PassportElementErrorReverseSide {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie
// changes.
pub struct PassportElementErrorSelfie {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with a document scan. The error is considered resolved when the file with the document scan
// changes.
pub struct PassportElementErrorFile {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans
// changes.
pub struct PassportElementErrorFiles {
pub:
    source string
    @type string
    file_hashes []string
    message string
}

// Represents an issue with one of the files that constitute the translation of a document. The error is considered
// resolved when the file changes.
pub struct PassportElementErrorTranslationFile {
pub:
    source string
    @type string
    file_hash string
    message string
}

// Represents an issue with the translated version of a document. The error is considered resolved when a file with the
// document translation change.
pub struct PassportElementErrorTranslationFiles {
pub:
    source string
    @type string
    file_hashes []string
    message string
}

// Represents an issue in an unspecified place. The error is considered resolved when new data is added.
pub struct PassportElementErrorUnspecified {
pub:
    source string
    @type string
    element_hash string
    message string
}

// This object represents a game. Use BotFather to create and edit games, their short names will act as unique
// identifiers.
pub struct Game {
pub:
    title string
    description string
    photo []PhotoSize
    text string
    text_entities []MessageEntity
    animation ?&Animation
}

// A placeholder, currently holds no information. Use BotFather to set up your game.
pub struct CallbackGame {}

// This object represents one row of the high scores table for a game.
pub struct GameHighScore {
pub:
    position i64
    user &User
    score i64
}

// Params for the `get_updates` function.
[params]
pub struct GetUpdatesParams {
pub mut:
    // Identifier of the first update to be returned. Must be greater by one than the highest among the identifiers of
    // previously received updates. By default, updates starting with the earliest unconfirmed update are returned. An
    // update is considered confirmed as soon as getUpdates is called with an offset higher than its update_id. The
    // negative offset can be specified to retrieve updates starting from -offset update from the end of the
    // updates queue. All previous updates will be forgotten.
    offset i64

    // Limits the number of updates to be retrieved. Values between 1-100 are accepted. Defaults to 100.
    limit i64

    // Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be positive, short polling should
    // be used for testing purposes only.
    timeout i64

    // A JSON-serialized list of the update types you want your bot to receive. For example, specify ["message",
    // "edited_channel_post", "callback_query"] to only receive updates of these types. See Update for a
    // complete list of available update types. Specify an empty list to receive all update types except
    // chat_member (default). If not specified, the previous setting will be used. Please note that this
    // parameter doesn't affect updates created before the call to the getUpdates, so unwanted updates
    // may be received for a short period of time.
    allowed_updates []string

}

// Use this method to receive incoming updates using long polling (wiki). Returns an Array of Update objects.
pub fn (ctx Context) get_updates(params GetUpdatesParams) ![]Update {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getUpdates", body)!
    res := json.decode(ApiResponse[[]Update], raw_json)!
    return res.result
}

// Params for the `set_webhook` function.
[params]
pub struct SetWebhookParams {
pub mut:
    // HTTPS URL to send updates to. Use an empty string to remove webhook integration
    url string [required]

    // Upload your public key certificate so that the root certificate in use can be checked. See our self-signed guide for
    // details.
    certificate InputFile

    // The fixed IP address which will be used to send webhook requests instead of the IP address resolved through DNS
    ip_address string

    // The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery, 1-100. Defaults to 40.
    // Use lower values to limit the load on your bot's server, and higher values to increase your bot's throughput.
    max_connections i64

    // A JSON-serialized list of the update types you want your bot to receive. For example, specify ["message",
    // "edited_channel_post", "callback_query"] to only receive updates of these types. See Update for a
    // complete list of available update types. Specify an empty list to receive all update types except
    // chat_member (default). If not specified, the previous setting will be used. Please note that this
    // parameter doesn't affect updates created before the call to the setWebhook, so unwanted updates
    // may be received for a short period of time.
    allowed_updates []string

    // Pass True to drop all pending updates
    drop_pending_updates bool

    // A secret token to be sent in a header "X-Telegram-Bot-Api-Secret-Token" in every webhook request, 1-256 characters.
    // Only characters A-Z, a-z, 0-9, _ and - are allowed. The header is useful to ensure that the request comes from a
    // webhook set by you.
    secret_token string

}

// Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever there is an update for
// the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized Update. In case of an
// unsuccessful request, we will give up after a reasonable amount of attempts. Returns True on success.
// If you'd like to make sure that the webhook was set by you, you can specify secret data in the parameter secret_token.
// If specified, the request will contain a header "X-Telegram-Bot-Api-Secret-Token" with the secret token as content.
pub fn (ctx Context) set_webhook(params SetWebhookParams) !bool {
    mut form := http.PostMultipartFormConfig{
        form: {
            "url": params.url,
            "ip_address": params.ip_address,
            "max_connections": params.max_connections.str(),
            "allowed_updates": params.allowed_updates.str(),
            "drop_pending_updates": params.drop_pending_updates.str(),
            "secret_token": params.secret_token,
        },
    }

    key := random_string(10)
    form.files[key] = []
    form.files[key] << http.FileData{
        filename: params.certificate.filename,
        content_type: params.certificate.content_type,
        data: params.certificate.data,
    }

    mut raw_json := ctx.request_multipart("setWebhook", form)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_webhook` function.
[params]
pub struct DeleteWebhookParams {
pub mut:
    // Pass True to drop all pending updates
    drop_pending_updates bool

}

// Use this method to remove webhook integration if you decide to switch back to getUpdates. Returns True on success.
pub fn (ctx Context) delete_webhook(params DeleteWebhookParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteWebhook", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Use this method to get current webhook status. Requires no parameters. On success, returns a WebhookInfo object. If the
// bot is using getUpdates, will return an object with the url field empty.
pub fn (ctx Context) get_webhook_info() !WebhookInfo {
    mut body := "{}"
    mut raw_json := ctx.request("getWebhookInfo", body)!
    res := json.decode(ApiResponse[WebhookInfo], raw_json)!
    return res.result
}

// A simple method for testing your bot's authentication token. Requires no parameters. Returns basic information about
// the bot in form of a User object.
pub fn (ctx Context) get_me() !User {
    mut body := "{}"
    mut raw_json := ctx.request("getMe", body)!
    res := json.decode(ApiResponse[User], raw_json)!
    return res.result
}

// Use this method to log out from the cloud Bot API server before launching the bot locally. You must log out the bot
// before running it locally, otherwise there is no guarantee that the bot will receive updates. After a successful
// call, you can immediately log in on a local server, but will not be able to log in back to the cloud Bot API
// server for 10 minutes. Returns True on success. Requires no parameters.
pub fn (ctx Context) log_out() !bool {
    mut body := "{}"
    mut raw_json := ctx.request("logOut", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Use this method to close the bot instance before moving it from one local server to another. You need to delete the
// webhook before calling this method to ensure that the bot isn't launched again after server restart. The method
// will return error 429 in the first 10 minutes after the bot is launched. Returns True on success. Requires no
// parameters.
pub fn (ctx Context) close() !bool {
    mut body := "{}"
    mut raw_json := ctx.request("close", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `send_message` function.
[params]
pub struct SendMessageParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Text of the message to be sent, 1-4096 characters after entities parsing
    text string [required]

    // Mode for parsing entities in the message text. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode
    entities []MessageEntity

    // Disables link previews for links in this message
    disable_web_page_preview bool

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send text messages. On success, the sent Message is returned.
pub fn (ctx Context) send_message(params SendMessageParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendMessage", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `forward_message` function.
[params]
pub struct ForwardMessageParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Unique identifier for the chat where the original message was sent (or channel username in the format @channelusername)
    from_chat_id IntegerOrString [required]

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the forwarded message from forwarding and saving
    protect_content bool

    // Message identifier in the chat specified in from_chat_id
    message_id i64 [required]

}

// Use this method to forward messages of any kind. Service messages can't be forwarded. On success, the sent Message is
// returned.
pub fn (ctx Context) forward_message(params ForwardMessageParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("forwardMessage", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `copy_message` function.
[params]
pub struct CopyMessageParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Unique identifier for the chat where the original message was sent (or channel username in the format @channelusername)
    from_chat_id IntegerOrString [required]

    // Message identifier in the chat specified in from_chat_id
    message_id i64 [required]

    // New caption for media, 0-1024 characters after entities parsing. If not specified, the original caption is kept
    caption string

    // Mode for parsing entities in the new caption. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in the new caption, which can be specified instead of parse_mode
    caption_entities []MessageEntity

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to copy messages of any kind. Service messages and invoice messages can't be copied. A quiz poll can be
// copied only if the value of the field correct_option_id is known to the bot. The method is analogous to the method
// forwardMessage, but the copied message doesn't have a link to the original message. Returns the MessageId of the
// sent message on success.
pub fn (ctx Context) copy_message(params CopyMessageParams) !MessageId {
    mut body := json.encode(params)
    mut raw_json := ctx.request("copyMessage", body)!
    res := json.decode(ApiResponse[MessageId], raw_json)!
    return res.result
}

// Params for the `send_photo` function.
[params]
pub struct SendPhotoParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Photo to send. Pass a file_id as String to send a photo that exists on the Telegram servers (recommended), pass an HTTP
    // URL as a String for Telegram to get a photo from the Internet, or upload a new photo using multipart/form-data. The
    // photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height
    // ratio must be at most 20. More information on Sending Files: https://core.telegram.org/bots/api#sending-files
    photo InputFileOrString [required]

    // Photo caption (may also be used when resending photos by file_id), 0-1024 characters after entities parsing
    caption string

    // Mode for parsing entities in the photo caption. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
    caption_entities []MessageEntity

    // Pass True if the photo needs to be covered with a spoiler animation
    has_spoiler bool

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send photos. On success, the sent Message is returned.
pub fn (ctx Context) send_photo(params SendPhotoParams) !Message {
    mut form := http.PostMultipartFormConfig{
        form: {
            "chat_id": json.encode(params.chat_id),
            "message_thread_id": params.message_thread_id.str(),
            "caption": params.caption,
            "parse_mode": params.parse_mode,
            "caption_entities": params.caption_entities.str(),
            "has_spoiler": params.has_spoiler.str(),
            "disable_notification": params.disable_notification.str(),
            "protect_content": params.protect_content.str(),
            "reply_to_message_id": params.reply_to_message_id.str(),
            "allow_sending_without_reply": params.allow_sending_without_reply.str(),
            "reply_markup": json.encode(params.reply_markup),
        },
    }

    key := random_string(10)
    form.files[key] = []
    if params.photo is InputFile {
        form.files[key] << http.FileData{
            filename: params.photo.filename,
            content_type: params.photo.content_type,
            data: params.photo.data,
        }
    } else {
        form.form["photo"] = params.photo as string
    }

    mut raw_json := ctx.request_multipart("sendPhoto", form)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_audio` function.
[params]
pub struct SendAudioParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Audio file to send. Pass a file_id as String to send an audio file that exists on the Telegram servers (recommended),
    // pass an HTTP URL as a String for Telegram to get an audio file from the Internet, or upload a new one using
    // multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files
    audio InputFileOrString [required]

    // Audio caption, 0-1024 characters after entities parsing
    caption string

    // Mode for parsing entities in the audio caption. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
    caption_entities []MessageEntity

    // Duration of the audio in seconds
    duration i64

    // Performer
    performer string

    // Track name
    title string

    // Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail
    // should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if
    // the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file,
    // so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under
    // <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files
    thumbnail InputFileOrString

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send audio files, if you want Telegram clients to display them in the music player. Your audio must
// be in the .MP3 or .M4A format. On success, the sent Message is returned. Bots can currently send audio files of up to
// 50 MB in size, this limit may be changed in the future.
// For sending voice messages, use the sendVoice method instead.
pub fn (ctx Context) send_audio(params SendAudioParams) !Message {
    mut form := http.PostMultipartFormConfig{
        form: {
            "chat_id": json.encode(params.chat_id),
            "message_thread_id": params.message_thread_id.str(),
            "caption": params.caption,
            "parse_mode": params.parse_mode,
            "caption_entities": params.caption_entities.str(),
            "duration": params.duration.str(),
            "performer": params.performer,
            "title": params.title,
            "disable_notification": params.disable_notification.str(),
            "protect_content": params.protect_content.str(),
            "reply_to_message_id": params.reply_to_message_id.str(),
            "allow_sending_without_reply": params.allow_sending_without_reply.str(),
            "reply_markup": json.encode(params.reply_markup),
        },
    }

    key := random_string(10)
    form.files[key] = []
    if params.audio is InputFile {
        form.files[key] << http.FileData{
            filename: params.audio.filename,
            content_type: params.audio.content_type,
            data: params.audio.data,
        }
    } else {
        form.form["audio"] = params.audio as string
    }

    if params.thumbnail is InputFile {
        form.files[key] << http.FileData{
            filename: params.thumbnail.filename,
            content_type: params.thumbnail.content_type,
            data: params.thumbnail.data,
        }
    } else {
        form.form["thumbnail"] = params.thumbnail as string
    }

    mut raw_json := ctx.request_multipart("sendAudio", form)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_document` function.
[params]
pub struct SendDocumentParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // File to send. Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP
    // URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data. More
    // information on Sending Files: https://core.telegram.org/bots/api#sending-files
    document InputFileOrString [required]

    // Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail
    // should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if
    // the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file,
    // so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under
    // <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files
    thumbnail InputFileOrString

    // Document caption (may also be used when resending documents by file_id), 0-1024 characters after entities parsing
    caption string

    // Mode for parsing entities in the document caption. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
    caption_entities []MessageEntity

    // Disables automatic server-side content type detection for files uploaded using multipart/form-data
    disable_content_type_detection bool

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send general files. On success, the sent Message is returned. Bots can currently send files of any
// type of up to 50 MB in size, this limit may be changed in the future.
pub fn (ctx Context) send_document(params SendDocumentParams) !Message {
    mut form := http.PostMultipartFormConfig{
        form: {
            "chat_id": json.encode(params.chat_id),
            "message_thread_id": params.message_thread_id.str(),
            "caption": params.caption,
            "parse_mode": params.parse_mode,
            "caption_entities": params.caption_entities.str(),
            "disable_content_type_detection": params.disable_content_type_detection.str(),
            "disable_notification": params.disable_notification.str(),
            "protect_content": params.protect_content.str(),
            "reply_to_message_id": params.reply_to_message_id.str(),
            "allow_sending_without_reply": params.allow_sending_without_reply.str(),
            "reply_markup": json.encode(params.reply_markup),
        },
    }

    key := random_string(10)
    form.files[key] = []
    if params.document is InputFile {
        form.files[key] << http.FileData{
            filename: params.document.filename,
            content_type: params.document.content_type,
            data: params.document.data,
        }
    } else {
        form.form["document"] = params.document as string
    }

    if params.thumbnail is InputFile {
        form.files[key] << http.FileData{
            filename: params.thumbnail.filename,
            content_type: params.thumbnail.content_type,
            data: params.thumbnail.data,
        }
    } else {
        form.form["thumbnail"] = params.thumbnail as string
    }

    mut raw_json := ctx.request_multipart("sendDocument", form)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_video` function.
[params]
pub struct SendVideoParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Video to send. Pass a file_id as String to send a video that exists on the Telegram servers (recommended), pass an HTTP
    // URL as a String for Telegram to get a video from the Internet, or upload a new video using multipart/form-data. More
    // information on Sending Files: https://core.telegram.org/bots/api#sending-files
    video InputFileOrString [required]

    // Duration of sent video in seconds
    duration i64

    // Video width
    width i64

    // Video height
    height i64

    // Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail
    // should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if
    // the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file,
    // so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under
    // <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files
    thumbnail InputFileOrString

    // Video caption (may also be used when resending videos by file_id), 0-1024 characters after entities parsing
    caption string

    // Mode for parsing entities in the video caption. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
    caption_entities []MessageEntity

    // Pass True if the video needs to be covered with a spoiler animation
    has_spoiler bool

    // Pass True if the uploaded video is suitable for streaming
    supports_streaming bool

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be sent as Document). On
// success, the sent Message is returned. Bots can currently send video files of up to 50 MB in size, this limit may be
// changed in the future.
pub fn (ctx Context) send_video(params SendVideoParams) !Message {
    mut form := http.PostMultipartFormConfig{
        form: {
            "chat_id": json.encode(params.chat_id),
            "message_thread_id": params.message_thread_id.str(),
            "duration": params.duration.str(),
            "width": params.width.str(),
            "height": params.height.str(),
            "caption": params.caption,
            "parse_mode": params.parse_mode,
            "caption_entities": params.caption_entities.str(),
            "has_spoiler": params.has_spoiler.str(),
            "supports_streaming": params.supports_streaming.str(),
            "disable_notification": params.disable_notification.str(),
            "protect_content": params.protect_content.str(),
            "reply_to_message_id": params.reply_to_message_id.str(),
            "allow_sending_without_reply": params.allow_sending_without_reply.str(),
            "reply_markup": json.encode(params.reply_markup),
        },
    }

    key := random_string(10)
    form.files[key] = []
    if params.video is InputFile {
        form.files[key] << http.FileData{
            filename: params.video.filename,
            content_type: params.video.content_type,
            data: params.video.data,
        }
    } else {
        form.form["video"] = params.video as string
    }

    if params.thumbnail is InputFile {
        form.files[key] << http.FileData{
            filename: params.thumbnail.filename,
            content_type: params.thumbnail.content_type,
            data: params.thumbnail.data,
        }
    } else {
        form.form["thumbnail"] = params.thumbnail as string
    }

    mut raw_json := ctx.request_multipart("sendVideo", form)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_animation` function.
[params]
pub struct SendAnimationParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Animation to send. Pass a file_id as String to send an animation that exists on the Telegram servers (recommended),
    // pass an HTTP URL as a String for Telegram to get an animation from the Internet, or upload a new animation using
    // multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files
    animation InputFileOrString [required]

    // Duration of sent animation in seconds
    duration i64

    // Animation width
    width i64

    // Animation height
    height i64

    // Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail
    // should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if
    // the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file,
    // so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under
    // <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files
    thumbnail InputFileOrString

    // Animation caption (may also be used when resending animation by file_id), 0-1024 characters after entities parsing
    caption string

    // Mode for parsing entities in the animation caption. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
    caption_entities []MessageEntity

    // Pass True if the animation needs to be covered with a spoiler animation
    has_spoiler bool

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success, the sent Message is
// returned. Bots can currently send animation files of up to 50 MB in size, this limit may be changed in the future.
pub fn (ctx Context) send_animation(params SendAnimationParams) !Message {
    mut form := http.PostMultipartFormConfig{
        form: {
            "chat_id": json.encode(params.chat_id),
            "message_thread_id": params.message_thread_id.str(),
            "duration": params.duration.str(),
            "width": params.width.str(),
            "height": params.height.str(),
            "caption": params.caption,
            "parse_mode": params.parse_mode,
            "caption_entities": params.caption_entities.str(),
            "has_spoiler": params.has_spoiler.str(),
            "disable_notification": params.disable_notification.str(),
            "protect_content": params.protect_content.str(),
            "reply_to_message_id": params.reply_to_message_id.str(),
            "allow_sending_without_reply": params.allow_sending_without_reply.str(),
            "reply_markup": json.encode(params.reply_markup),
        },
    }

    key := random_string(10)
    form.files[key] = []
    if params.animation is InputFile {
        form.files[key] << http.FileData{
            filename: params.animation.filename,
            content_type: params.animation.content_type,
            data: params.animation.data,
        }
    } else {
        form.form["animation"] = params.animation as string
    }

    if params.thumbnail is InputFile {
        form.files[key] << http.FileData{
            filename: params.thumbnail.filename,
            content_type: params.thumbnail.content_type,
            data: params.thumbnail.data,
        }
    } else {
        form.form["thumbnail"] = params.thumbnail as string
    }

    mut raw_json := ctx.request_multipart("sendAnimation", form)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_voice` function.
[params]
pub struct SendVoiceParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Audio file to send. Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an
    // HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data. More
    // information on Sending Files: https://core.telegram.org/bots/api#sending-files
    voice InputFileOrString [required]

    // Voice message caption, 0-1024 characters after entities parsing
    caption string

    // Mode for parsing entities in the voice message caption. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
    caption_entities []MessageEntity

    // Duration of the voice message in seconds
    duration i64

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send audio files, if you want Telegram clients to display the file as a playable voice message. For
// this to work, your audio must be in an .OGG file encoded with OPUS (other formats may be sent as Audio or Document).
// On success, the sent Message is returned. Bots can currently send voice messages of up to 50 MB in size, this limit
// may be changed in the future.
pub fn (ctx Context) send_voice(params SendVoiceParams) !Message {
    mut form := http.PostMultipartFormConfig{
        form: {
            "chat_id": json.encode(params.chat_id),
            "message_thread_id": params.message_thread_id.str(),
            "caption": params.caption,
            "parse_mode": params.parse_mode,
            "caption_entities": params.caption_entities.str(),
            "duration": params.duration.str(),
            "disable_notification": params.disable_notification.str(),
            "protect_content": params.protect_content.str(),
            "reply_to_message_id": params.reply_to_message_id.str(),
            "allow_sending_without_reply": params.allow_sending_without_reply.str(),
            "reply_markup": json.encode(params.reply_markup),
        },
    }

    key := random_string(10)
    form.files[key] = []
    if params.voice is InputFile {
        form.files[key] << http.FileData{
            filename: params.voice.filename,
            content_type: params.voice.content_type,
            data: params.voice.data,
        }
    } else {
        form.form["voice"] = params.voice as string
    }

    mut raw_json := ctx.request_multipart("sendVoice", form)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_video_note` function.
[params]
pub struct SendVideoNoteParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Video note to send. Pass a file_id as String to send a video note that exists on the Telegram servers (recommended) or
    // upload a new video using multipart/form-data. More information on Sending Files:
    // https://core.telegram.org/bots/api#sending-files. Sending video notes by a URL
    // is currently unsupported
    video_note InputFileOrString [required]

    // Duration of sent video in seconds
    duration i64

    // Video width and height, i.e. diameter of the video message
    length i64

    // Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail
    // should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if
    // the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file,
    // so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under
    // <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files
    thumbnail InputFileOrString

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// As of v.4.0, Telegram clients support rounded square MPEG4 videos of up to 1 minute long. Use this method to send video
// messages. On success, the sent Message is returned.
pub fn (ctx Context) send_video_note(params SendVideoNoteParams) !Message {
    mut form := http.PostMultipartFormConfig{
        form: {
            "chat_id": json.encode(params.chat_id),
            "message_thread_id": params.message_thread_id.str(),
            "duration": params.duration.str(),
            "length": params.length.str(),
            "disable_notification": params.disable_notification.str(),
            "protect_content": params.protect_content.str(),
            "reply_to_message_id": params.reply_to_message_id.str(),
            "allow_sending_without_reply": params.allow_sending_without_reply.str(),
            "reply_markup": json.encode(params.reply_markup),
        },
    }

    key := random_string(10)
    form.files[key] = []
    if params.video_note is InputFile {
        form.files[key] << http.FileData{
            filename: params.video_note.filename,
            content_type: params.video_note.content_type,
            data: params.video_note.data,
        }
    } else {
        form.form["video_note"] = params.video_note as string
    }

    if params.thumbnail is InputFile {
        form.files[key] << http.FileData{
            filename: params.thumbnail.filename,
            content_type: params.thumbnail.content_type,
            data: params.thumbnail.data,
        }
    } else {
        form.form["thumbnail"] = params.thumbnail as string
    }

    mut raw_json := ctx.request_multipart("sendVideoNote", form)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_media_group` function.
[params]
pub struct SendMediaGroupParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // A JSON-serialized array describing messages to be sent, must include 2-10 items
    media []InputMediaAudioOrInputMediaDocumentOrInputMediaPhotoOrInputMediaVideo [required]

    // Sends messages silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent messages from forwarding and saving
    protect_content bool

    // If the messages are a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

}

// Use this method to send a group of photos, videos, documents or audios as an album. Documents and audio files can be
// only grouped in an album with messages of the same type. On success, an array of Messages that were sent is
// returned.
pub fn (ctx Context) send_media_group(params SendMediaGroupParams) ![]Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendMediaGroup", body)!
    res := json.decode(ApiResponse[[]Message], raw_json)!
    return res.result
}

// Params for the `send_location` function.
[params]
pub struct SendLocationParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Latitude of the location
    latitude f64 [required]

    // Longitude of the location
    longitude f64 [required]

    // The radius of uncertainty for the location, measured in meters; 0-1500
    horizontal_accuracy f64

    // Period in seconds for which the location will be updated (see Live Locations, should be between 60 and 86400.
    live_period i64

    // For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
    heading i64

    // For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be
    // between 1 and 100000 if specified.
    proximity_alert_radius i64

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send point on the map. On success, the sent Message is returned.
pub fn (ctx Context) send_location(params SendLocationParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendLocation", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_venue` function.
[params]
pub struct SendVenueParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Latitude of the venue
    latitude f64 [required]

    // Longitude of the venue
    longitude f64 [required]

    // Name of the venue
    title string [required]

    // Address of the venue
    address string [required]

    // Foursquare identifier of the venue
    foursquare_id string

    // Foursquare type of the venue, if known. (For example, "arts_entertainment/default", "arts_entertainment/aquarium" or
    // "food/icecream".)
    foursquare_type string

    // Google Places identifier of the venue
    google_place_id string

    // Google Places type of the venue. (See supported types.)
    google_place_type string

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send information about a venue. On success, the sent Message is returned.
pub fn (ctx Context) send_venue(params SendVenueParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendVenue", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_contact` function.
[params]
pub struct SendContactParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Contact's phone number
    phone_number string [required]

    // Contact's first name
    first_name string [required]

    // Contact's last name
    last_name string

    // Additional data about the contact in the form of a vCard, 0-2048 bytes
    vcard string

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send phone contacts. On success, the sent Message is returned.
pub fn (ctx Context) send_contact(params SendContactParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendContact", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_poll` function.
[params]
pub struct SendPollParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Poll question, 1-300 characters
    question string [required]

    // A JSON-serialized list of answer options, 2-10 strings 1-100 characters each
    options []string [required]

    // True, if the poll needs to be anonymous, defaults to True
    is_anonymous bool

    // Poll type, "quiz" or "regular", defaults to "regular"
    @type string

    // True, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to False
    allows_multiple_answers bool

    // 0-based identifier of the correct answer option, required for polls in quiz mode
    correct_option_id i64

    // Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200
    // characters with at most 2 line feeds after entities parsing
    explanation string

    // Mode for parsing entities in the explanation. See formatting options for more details.
    explanation_parse_mode string

    // A JSON-serialized list of special entities that appear in the poll explanation, which can be specified instead of
    // parse_mode
    explanation_entities []MessageEntity

    // Amount of time in seconds the poll will be active after creation, 5-600. Can't be used together with close_date.
    open_period i64

    // Point in time (Unix timestamp) when the poll will be automatically closed. Must be at least 5 and no more than 600
    // seconds in the future. Can't be used together with open_period.
    close_date i64

    // Pass True if the poll needs to be immediately closed. This can be useful for poll preview.
    is_closed bool

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send a native poll. On success, the sent Message is returned.
pub fn (ctx Context) send_poll(params SendPollParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendPoll", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_dice` function.
[params]
pub struct SendDiceParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Emoji on which the dice throw animation is based. Currently, must be one of "🎲", "🎯", "🏀", "⚽", "🎳", or
    // "🎰". Dice can have values 1-6 for "🎲", "🎯" and "🎳", values 1-5 for "🏀" and "⚽", and values 1-64 for
    // "🎰". Defaults to "🎲"
    emoji string

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send an animated emoji that will display a random value. On success, the sent Message is returned.
pub fn (ctx Context) send_dice(params SendDiceParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendDice", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `send_chat_action` function.
[params]
pub struct SendChatActionParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread; supergroups only
    message_thread_id i64

    // Type of action to broadcast. Choose one, depending on what the user is about to receive: typing for text messages,
    // upload_photo for photos, record_video or upload_video for videos, record_voice or upload_voice for voice notes,
    // upload_document for general files, choose_sticker for stickers, find_location for location data,
    // record_video_note or upload_video_note for video notes.
    action string [required]

}

// Use this method when you need to tell the user that something is happening on the bot's side. The status is set for 5
// seconds or less (when a message arrives from your bot, Telegram clients clear its typing status). Returns True on
// success.
// We only recommend using this method when a response from the bot will take a noticeable amount of time to arrive.
pub fn (ctx Context) send_chat_action(params SendChatActionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendChatAction", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_user_profile_photos` function.
[params]
pub struct GetUserProfilePhotosParams {
pub mut:
    // Unique identifier of the target user
    user_id i64 [required]

    // Sequential number of the first photo to be returned. By default, all photos are returned.
    offset i64

    // Limits the number of photos to be retrieved. Values between 1-100 are accepted. Defaults to 100.
    limit i64

}

// Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos object.
pub fn (ctx Context) get_user_profile_photos(params GetUserProfilePhotosParams) !UserProfilePhotos {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getUserProfilePhotos", body)!
    res := json.decode(ApiResponse[UserProfilePhotos], raw_json)!
    return res.result
}

// Params for the `get_file` function.
[params]
pub struct GetFileParams {
pub mut:
    // File identifier to get information about
    file_id string [required]

}

// Use this method to get basic information about a file and prepare it for downloading. For the moment, bots can download
// files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link
// https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken from the response. It is
// guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be
// requested by calling getFile again.
// Note: This function may not preserve the original file name and MIME type. You should save the file's MIME type and
// name (if available) when the File object is received.
pub fn (ctx Context) get_file(params GetFileParams) !File {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getFile", body)!
    res := json.decode(ApiResponse[File], raw_json)!
    return res.result
}

// Params for the `ban_chat_member` function.
[params]
pub struct BanChatMemberParams {
pub mut:
    // Unique identifier for the target group or username of the target supergroup or channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target user
    user_id i64 [required]

    // Date when the user will be unbanned, unix time. If user is banned for more than 366 days or less than 30 seconds from
    // the current time they are considered to be banned forever. Applied for supergroups and channels only.
    until_date i64

    // Pass True to delete all messages from the chat for the user that is being removed. If False, the user will be able to
    // see messages in the group that were sent before the user was removed. Always True for supergroups and channels.
    revoke_messages bool

}

// Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups and channels, the user
// will not be able to return to the chat on their own using invite links, etc., unless unbanned first. The bot must be
// an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on
// success.
pub fn (ctx Context) ban_chat_member(params BanChatMemberParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("banChatMember", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unban_chat_member` function.
[params]
pub struct UnbanChatMemberParams {
pub mut:
    // Unique identifier for the target group or username of the target supergroup or channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target user
    user_id i64 [required]

    // Do nothing if the user is not banned
    only_if_banned bool

}

// Use this method to unban a previously banned user in a supergroup or channel. The user will not return to the group or
// channel automatically, but will be able to join via link, etc. The bot must be an administrator for this to work. By
// default, this method guarantees that after the call the user is not a member of the chat, but will be able to join
// it. So if the user is a member of the chat they will also be removed from the chat. If you don't want this, use
// the parameter only_if_banned. Returns True on success.
pub fn (ctx Context) unban_chat_member(params UnbanChatMemberParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unbanChatMember", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `restrict_chat_member` function.
[params]
pub struct RestrictChatMemberParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target user
    user_id i64 [required]

    // A JSON-serialized object for new user permissions
    permissions ChatPermissions [required]

    // Pass True if chat permissions are set independently. Otherwise, the can_send_other_messages and
    // can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios,
    // can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and
    // can_send_voice_notes permissions; the can_send_polls permission will imply the
    // can_send_messages permission.
    use_independent_chat_permissions bool

    // Date when restrictions will be lifted for the user, unix time. If user is restricted for more than 366 days or less
    // than 30 seconds from the current time, they are considered to be restricted forever
    until_date i64

}

// Use this method to restrict a user in a supergroup. The bot must be an administrator in the supergroup for this to work
// and must have the appropriate administrator rights. Pass True for all permissions to lift restrictions from a user.
// Returns True on success.
pub fn (ctx Context) restrict_chat_member(params RestrictChatMemberParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("restrictChatMember", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `promote_chat_member` function.
[params]
pub struct PromoteChatMemberParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target user
    user_id i64 [required]

    // Pass True if the administrator's presence in the chat is hidden
    is_anonymous bool

    // Pass True if the administrator can access the chat event log, chat statistics, message statistics in channels, see
    // channel members, see anonymous administrators in supergroups and ignore slow mode. Implied by any other
    // administrator privilege
    can_manage_chat bool

    // Pass True if the administrator can create channel posts, channels only
    can_post_messages bool

    // Pass True if the administrator can edit messages of other users and can pin messages, channels only
    can_edit_messages bool

    // Pass True if the administrator can delete messages of other users
    can_delete_messages bool

    // Pass True if the administrator can manage video chats
    can_manage_video_chats bool

    // Pass True if the administrator can restrict, ban or unban chat members
    can_restrict_members bool

    // Pass True if the administrator can add new administrators with a subset of their own privileges or demote
    // administrators that they have promoted, directly or indirectly (promoted by administrators that were
    // appointed by him)
    can_promote_members bool

    // Pass True if the administrator can change chat title, photo and other settings
    can_change_info bool

    // Pass True if the administrator can invite new users to the chat
    can_invite_users bool

    // Pass True if the administrator can pin messages, supergroups only
    can_pin_messages bool

    // Pass True if the user is allowed to create, rename, close, and reopen forum topics, supergroups only
    can_manage_topics bool

}

// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in the chat
// for this to work and must have the appropriate administrator rights. Pass False for all boolean parameters to demote a
// user. Returns True on success.
pub fn (ctx Context) promote_chat_member(params PromoteChatMemberParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("promoteChatMember", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_administrator_custom_title` function.
[params]
pub struct SetChatAdministratorCustomTitleParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target user
    user_id i64 [required]

    // New custom title for the administrator; 0-16 characters, emoji are not allowed
    custom_title string [required]

}

// Use this method to set a custom title for an administrator in a supergroup promoted by the bot. Returns True on
// success.
pub fn (ctx Context) set_chat_administrator_custom_title(params SetChatAdministratorCustomTitleParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatAdministratorCustomTitle", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `ban_chat_sender_chat` function.
[params]
pub struct BanChatSenderChatParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target sender chat
    sender_chat_id i64 [required]

}

// Use this method to ban a channel chat in a supergroup or a channel. Until the chat is unbanned, the owner of the banned
// chat won't be able to send messages on behalf of any of their channels. The bot must be an administrator in the
// supergroup or channel for this to work and must have the appropriate administrator rights. Returns True on
// success.
pub fn (ctx Context) ban_chat_sender_chat(params BanChatSenderChatParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("banChatSenderChat", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unban_chat_sender_chat` function.
[params]
pub struct UnbanChatSenderChatParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target sender chat
    sender_chat_id i64 [required]

}

// Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must be an administrator
// for this to work and must have the appropriate administrator rights. Returns True on success.
pub fn (ctx Context) unban_chat_sender_chat(params UnbanChatSenderChatParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unbanChatSenderChat", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_permissions` function.
[params]
pub struct SetChatPermissionsParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // A JSON-serialized object for new default chat permissions
    permissions ChatPermissions [required]

    // Pass True if chat permissions are set independently. Otherwise, the can_send_other_messages and
    // can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios,
    // can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and
    // can_send_voice_notes permissions; the can_send_polls permission will imply the
    // can_send_messages permission.
    use_independent_chat_permissions bool

}

// Use this method to set default chat permissions for all members. The bot must be an administrator in the group or a
// supergroup for this to work and must have the can_restrict_members administrator rights. Returns True on success.
pub fn (ctx Context) set_chat_permissions(params SetChatPermissionsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatPermissions", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `export_chat_invite_link` function.
[params]
pub struct ExportChatInviteLinkParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

}

// Use this method to generate a new primary invite link for a chat; any previously generated primary link is revoked. The
// bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns
// the new invite link as String on success.
pub fn (ctx Context) export_chat_invite_link(params ExportChatInviteLinkParams) !string {
    mut body := json.encode(params)
    mut raw_json := ctx.request("exportChatInviteLink", body)!
    res := json.decode(ApiResponse[string], raw_json)!
    return res.result
}

// Params for the `create_chat_invite_link` function.
[params]
pub struct CreateChatInviteLinkParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Invite link name; 0-32 characters
    name string

    // Point in time (Unix timestamp) when the link will expire
    expire_date i64

    // The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link;
    // 1-99999
    member_limit i64

    // True, if users joining the chat via the link need to be approved by chat administrators. If True, member_limit can't be
    // specified
    creates_join_request bool

}

// Use this method to create an additional invite link for a chat. The bot must be an administrator in the chat for this
// to work and must have the appropriate administrator rights. The link can be revoked using the method
// revokeChatInviteLink. Returns the new invite link as ChatInviteLink object.
pub fn (ctx Context) create_chat_invite_link(params CreateChatInviteLinkParams) !ChatInviteLink {
    mut body := json.encode(params)
    mut raw_json := ctx.request("createChatInviteLink", body)!
    res := json.decode(ApiResponse[ChatInviteLink], raw_json)!
    return res.result
}

// Params for the `edit_chat_invite_link` function.
[params]
pub struct EditChatInviteLinkParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // The invite link to edit
    invite_link string [required]

    // Invite link name; 0-32 characters
    name string

    // Point in time (Unix timestamp) when the link will expire
    expire_date i64

    // The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link;
    // 1-99999
    member_limit i64

    // True, if users joining the chat via the link need to be approved by chat administrators. If True, member_limit can't be
    // specified
    creates_join_request bool

}

// Use this method to edit a non-primary invite link created by the bot. The bot must be an administrator in the chat for
// this to work and must have the appropriate administrator rights. Returns the edited invite link as a ChatInviteLink
// object.
pub fn (ctx Context) edit_chat_invite_link(params EditChatInviteLinkParams) !ChatInviteLink {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editChatInviteLink", body)!
    res := json.decode(ApiResponse[ChatInviteLink], raw_json)!
    return res.result
}

// Params for the `revoke_chat_invite_link` function.
[params]
pub struct RevokeChatInviteLinkParams {
pub mut:
    // Unique identifier of the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // The invite link to revoke
    invite_link string [required]

}

// Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new link is
// automatically generated. The bot must be an administrator in the chat for this to work and must have the
// appropriate administrator rights. Returns the revoked invite link as ChatInviteLink object.
pub fn (ctx Context) revoke_chat_invite_link(params RevokeChatInviteLinkParams) !ChatInviteLink {
    mut body := json.encode(params)
    mut raw_json := ctx.request("revokeChatInviteLink", body)!
    res := json.decode(ApiResponse[ChatInviteLink], raw_json)!
    return res.result
}

// Params for the `approve_chat_join_request` function.
[params]
pub struct ApproveChatJoinRequestParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target user
    user_id i64 [required]

}

// Use this method to approve a chat join request. The bot must be an administrator in the chat for this to work and must
// have the can_invite_users administrator right. Returns True on success.
pub fn (ctx Context) approve_chat_join_request(params ApproveChatJoinRequestParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("approveChatJoinRequest", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `decline_chat_join_request` function.
[params]
pub struct DeclineChatJoinRequestParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target user
    user_id i64 [required]

}

// Use this method to decline a chat join request. The bot must be an administrator in the chat for this to work and must
// have the can_invite_users administrator right. Returns True on success.
pub fn (ctx Context) decline_chat_join_request(params DeclineChatJoinRequestParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("declineChatJoinRequest", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_photo` function.
[params]
pub struct SetChatPhotoParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // New chat photo, uploaded using multipart/form-data
    photo InputFile [required]

}

// Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on
// success.
pub fn (ctx Context) set_chat_photo(params SetChatPhotoParams) !bool {
    mut form := http.PostMultipartFormConfig{
        form: {
            "chat_id": json.encode(params.chat_id),
        },
    }

    key := random_string(10)
    form.files[key] = []
    form.files[key] << http.FileData{
        filename: params.photo.filename,
        content_type: params.photo.content_type,
        data: params.photo.data,
    }

    mut raw_json := ctx.request_multipart("setChatPhoto", form)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_chat_photo` function.
[params]
pub struct DeleteChatPhotoParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

}

// Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be an administrator in
// the chat for this to work and must have the appropriate administrator rights. Returns True on success.
pub fn (ctx Context) delete_chat_photo(params DeleteChatPhotoParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteChatPhoto", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_title` function.
[params]
pub struct SetChatTitleParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // New chat title, 1-128 characters
    title string [required]

}

// Use this method to change the title of a chat. Titles can't be changed for private chats. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights. Returns True
// on success.
pub fn (ctx Context) set_chat_title(params SetChatTitleParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatTitle", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_chat_description` function.
[params]
pub struct SetChatDescriptionParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // New chat description, 0-255 characters
    description string

}

// Use this method to change the description of a group, a supergroup or a channel. The bot must be an administrator in
// the chat for this to work and must have the appropriate administrator rights. Returns True on success.
pub fn (ctx Context) set_chat_description(params SetChatDescriptionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatDescription", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `pin_chat_message` function.
[params]
pub struct PinChatMessageParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Identifier of a message to pin
    message_id i64 [required]

    // Pass True if it is not necessary to send a notification to all chat members about the new pinned message. Notifications
    // are always disabled in channels and private chats.
    disable_notification bool

}

// Use this method to add a message to the list of pinned messages in a chat. If the chat is not a private chat, the bot
// must be an administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in a
// supergroup or 'can_edit_messages' administrator right in a channel. Returns True on success.
pub fn (ctx Context) pin_chat_message(params PinChatMessageParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("pinChatMessage", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unpin_chat_message` function.
[params]
pub struct UnpinChatMessageParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Identifier of a message to unpin. If not specified, the most recent pinned message (by sending date) will be unpinned.
    message_id i64

}

// Use this method to remove a message from the list of pinned messages in a chat. If the chat is not a private chat, the
// bot must be an administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in
// a supergroup or 'can_edit_messages' administrator right in a channel. Returns True on success.
pub fn (ctx Context) unpin_chat_message(params UnpinChatMessageParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unpinChatMessage", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unpin_all_chat_messages` function.
[params]
pub struct UnpinAllChatMessagesParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

}

// Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an
// administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in a supergroup
// or 'can_edit_messages' administrator right in a channel. Returns True on success.
pub fn (ctx Context) unpin_all_chat_messages(params UnpinAllChatMessagesParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unpinAllChatMessages", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `leave_chat` function.
[params]
pub struct LeaveChatParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
    chat_id IntegerOrString [required]

}

// Use this method for your bot to leave a group, supergroup or channel. Returns True on success.
pub fn (ctx Context) leave_chat(params LeaveChatParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("leaveChat", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_chat` function.
[params]
pub struct GetChatParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
    chat_id IntegerOrString [required]

}

// Use this method to get up to date information about the chat (current name of the user for one-on-one conversations,
// current username of a user, group or channel, etc.). Returns a Chat object on success.
pub fn (ctx Context) get_chat(params GetChatParams) !Chat {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChat", body)!
    res := json.decode(ApiResponse[Chat], raw_json)!
    return res.result
}

// Params for the `get_chat_administrators` function.
[params]
pub struct GetChatAdministratorsParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
    chat_id IntegerOrString [required]

}

// Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array of ChatMember objects.
pub fn (ctx Context) get_chat_administrators(params GetChatAdministratorsParams) ![]ChatMember {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChatAdministrators", body)!
    res := json.decode(ApiResponse[[]ChatMember], raw_json)!
    return res.result
}

// Params for the `get_chat_member_count` function.
[params]
pub struct GetChatMemberCountParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
    chat_id IntegerOrString [required]

}

// Use this method to get the number of members in a chat. Returns Int on success.
pub fn (ctx Context) get_chat_member_count(params GetChatMemberCountParams) !i64 {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChatMemberCount", body)!
    res := json.decode(ApiResponse[i64], raw_json)!
    return res.result
}

// Params for the `get_chat_member` function.
[params]
pub struct GetChatMemberParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier of the target user
    user_id i64 [required]

}

// Use this method to get information about a member of a chat. The method is only guaranteed to work for other users if
// the bot is an administrator in the chat. Returns a ChatMember object on success.
pub fn (ctx Context) get_chat_member(params GetChatMemberParams) !ChatMember {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChatMember", body)!
    res := json.decode(ApiResponse[ChatMember], raw_json)!
    return res.result
}

// Params for the `set_chat_sticker_set` function.
[params]
pub struct SetChatStickerSetParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // Name of the sticker set to be set as the group sticker set
    sticker_set_name string [required]

}

// Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat for this
// to work and must have the appropriate administrator rights. Use the field can_set_sticker_set optionally returned in
// getChat requests to check if the bot can use this method. Returns True on success.
pub fn (ctx Context) set_chat_sticker_set(params SetChatStickerSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatStickerSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_chat_sticker_set` function.
[params]
pub struct DeleteChatStickerSetParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

}

// Use this method to delete a group sticker set from a supergroup. The bot must be an administrator in the chat for this
// to work and must have the appropriate administrator rights. Use the field can_set_sticker_set optionally returned in
// getChat requests to check if the bot can use this method. Returns True on success.
pub fn (ctx Context) delete_chat_sticker_set(params DeleteChatStickerSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteChatStickerSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user. Requires no
// parameters. Returns an Array of Sticker objects.
pub fn (ctx Context) get_forum_topic_icon_stickers() ![]Sticker {
    mut body := "{}"
    mut raw_json := ctx.request("getForumTopicIconStickers", body)!
    res := json.decode(ApiResponse[[]Sticker], raw_json)!
    return res.result
}

// Params for the `create_forum_topic` function.
[params]
pub struct CreateForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // Topic name, 1-128 characters
    name string [required]

    // Color of the topic icon in RGB format. Currently, must be one of 7322096 (0x6FB9F0), 16766590 (0xFFD67E), 13338331
    // (0xCB86DB), 9367192 (0x8EEE98), 16749490 (0xFF93B2), or 16478047 (0xFB6F5F)
    icon_color i64

    // Unique identifier of the custom emoji shown as the topic icon. Use getForumTopicIconStickers to get all allowed custom
    // emoji identifiers.
    icon_custom_emoji_id string

}

// Use this method to create a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to
// work and must have the can_manage_topics administrator rights. Returns information about the created topic as a
// ForumTopic object.
pub fn (ctx Context) create_forum_topic(params CreateForumTopicParams) !ForumTopic {
    mut body := json.encode(params)
    mut raw_json := ctx.request("createForumTopic", body)!
    res := json.decode(ApiResponse[ForumTopic], raw_json)!
    return res.result
}

// Params for the `edit_forum_topic` function.
[params]
pub struct EditForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread of the forum topic
    message_thread_id i64 [required]

    // New topic name, 0-128 characters. If not specified or empty, the current name of the topic will be kept
    name string

    // New unique identifier of the custom emoji shown as the topic icon. Use getForumTopicIconStickers to get all allowed
    // custom emoji identifiers. Pass an empty string to remove the icon. If not specified, the current icon will be kept
    icon_custom_emoji_id string

}

// Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an administrator in the
// chat for this to work and must have can_manage_topics administrator rights, unless it is the creator of the topic.
// Returns True on success.
pub fn (ctx Context) edit_forum_topic(params EditForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `close_forum_topic` function.
[params]
pub struct CloseForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread of the forum topic
    message_thread_id i64 [required]

}

// Use this method to close an open topic in a forum supergroup chat. The bot must be an administrator in the chat for
// this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.
// Returns True on success.
pub fn (ctx Context) close_forum_topic(params CloseForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("closeForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `reopen_forum_topic` function.
[params]
pub struct ReopenForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread of the forum topic
    message_thread_id i64 [required]

}

// Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an administrator in the chat for
// this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic. Returns
// True on success.
pub fn (ctx Context) reopen_forum_topic(params ReopenForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("reopenForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_forum_topic` function.
[params]
pub struct DeleteForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread of the forum topic
    message_thread_id i64 [required]

}

// Use this method to delete a forum topic along with all its messages in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the can_delete_messages administrator rights. Returns
// True on success.
pub fn (ctx Context) delete_forum_topic(params DeleteForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unpin_all_forum_topic_messages` function.
[params]
pub struct UnpinAllForumTopicMessagesParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread of the forum topic
    message_thread_id i64 [required]

}

// Use this method to clear the list of pinned messages in a forum topic. The bot must be an administrator in the chat for
// this to work and must have the can_pin_messages administrator right in the supergroup. Returns True on success.
pub fn (ctx Context) unpin_all_forum_topic_messages(params UnpinAllForumTopicMessagesParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unpinAllForumTopicMessages", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `edit_general_forum_topic` function.
[params]
pub struct EditGeneralForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

    // New topic name, 1-128 characters
    name string [required]

}

// Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must be an administrator in
// the chat for this to work and must have can_manage_topics administrator rights. Returns True on success.
pub fn (ctx Context) edit_general_forum_topic(params EditGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `close_general_forum_topic` function.
[params]
pub struct CloseGeneralForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

}

// Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an administrator in the
// chat for this to work and must have the can_manage_topics administrator rights. Returns True on success.
pub fn (ctx Context) close_general_forum_topic(params CloseGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("closeGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `reopen_general_forum_topic` function.
[params]
pub struct ReopenGeneralForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

}

// Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be an administrator in the
// chat for this to work and must have the can_manage_topics administrator rights. The topic will be automatically
// unhidden if it was hidden. Returns True on success.
pub fn (ctx Context) reopen_general_forum_topic(params ReopenGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("reopenGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `hide_general_forum_topic` function.
[params]
pub struct HideGeneralForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

}

// Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat
// for this to work and must have the can_manage_topics administrator rights. The topic will be automatically closed if
// it was open. Returns True on success.
pub fn (ctx Context) hide_general_forum_topic(params HideGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("hideGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `unhide_general_forum_topic` function.
[params]
pub struct UnhideGeneralForumTopicParams {
pub mut:
    // Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
    chat_id IntegerOrString [required]

}

// Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat
// for this to work and must have the can_manage_topics administrator rights. Returns True on success.
pub fn (ctx Context) unhide_general_forum_topic(params UnhideGeneralForumTopicParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("unhideGeneralForumTopic", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `answer_callback_query` function.
[params]
pub struct AnswerCallbackQueryParams {
pub mut:
    // Unique identifier for the query to be answered
    callback_query_id string [required]

    // Text of the notification. If not specified, nothing will be shown to the user, 0-200 characters
    text string

    // If True, an alert will be shown by the client instead of a notification at the top of the chat screen. Defaults to
    // false.
    show_alert bool

    // URL that will be opened by the user's client. If you have created a Game and accepted the conditions via @BotFather,
    // specify the URL that opens your game - note that this will only work if the query comes from a callback_game button.
    // Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter.
    url string

    // The maximum amount of time in seconds that the result of the callback query may be cached client-side. Telegram apps
    // will support caching starting in version 3.14. Defaults to 0.
    cache_time i64

}

// Use this method to send answers to callback queries sent from inline keyboards. The answer will be displayed to the
// user as a notification at the top of the chat screen or as an alert. On success, True is returned.
pub fn (ctx Context) answer_callback_query(params AnswerCallbackQueryParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerCallbackQuery", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_my_commands` function.
[params]
pub struct SetMyCommandsParams {
pub mut:
    // A JSON-serialized list of bot commands to be set as the list of the bot's commands. At most 100 commands can be
    // specified.
    commands []BotCommand [required]

    // A JSON-serialized object, describing scope of users for which the commands are relevant. Defaults to
    // BotCommandScopeDefault.
    scope BotCommandScope

    // A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose
    // language there are no dedicated commands
    language_code string

}

// Use this method to change the list of the bot's commands. See this manual for more details about bot commands. Returns
// True on success.
pub fn (ctx Context) set_my_commands(params SetMyCommandsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyCommands", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_my_commands` function.
[params]
pub struct DeleteMyCommandsParams {
pub mut:
    // A JSON-serialized object, describing scope of users for which the commands are relevant. Defaults to
    // BotCommandScopeDefault.
    scope BotCommandScope

    // A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose
    // language there are no dedicated commands
    language_code string

}

// Use this method to delete the list of the bot's commands for the given scope and user language. After deletion, higher
// level commands will be shown to affected users. Returns True on success.
pub fn (ctx Context) delete_my_commands(params DeleteMyCommandsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteMyCommands", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_commands` function.
[params]
pub struct GetMyCommandsParams {
pub mut:
    // A JSON-serialized object, describing scope of users. Defaults to BotCommandScopeDefault.
    scope BotCommandScope

    // A two-letter ISO 639-1 language code or an empty string
    language_code string

}

// Use this method to get the current list of the bot's commands for the given scope and user language. Returns an Array
// of BotCommand objects. If commands aren't set, an empty list is returned.
pub fn (ctx Context) get_my_commands(params GetMyCommandsParams) ![]BotCommand {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyCommands", body)!
    res := json.decode(ApiResponse[[]BotCommand], raw_json)!
    return res.result
}

// Params for the `set_my_name` function.
[params]
pub struct SetMyNameParams {
pub mut:
    // New bot name; 0-64 characters. Pass an empty string to remove the dedicated name for the given language.
    name string

    // A two-letter ISO 639-1 language code. If empty, the name will be shown to all users for whose language there is no
    // dedicated name.
    language_code string

}

// Use this method to change the bot's name. Returns True on success.
pub fn (ctx Context) set_my_name(params SetMyNameParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyName", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_name` function.
[params]
pub struct GetMyNameParams {
pub mut:
    // A two-letter ISO 639-1 language code or an empty string
    language_code string

}

// Use this method to get the current bot name for the given user language. Returns BotName on success.
pub fn (ctx Context) get_my_name(params GetMyNameParams) !BotName {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyName", body)!
    res := json.decode(ApiResponse[BotName], raw_json)!
    return res.result
}

// Params for the `set_my_description` function.
[params]
pub struct SetMyDescriptionParams {
pub mut:
    // New bot description; 0-512 characters. Pass an empty string to remove the dedicated description for the given language.
    description string

    // A two-letter ISO 639-1 language code. If empty, the description will be applied to all users for whose language there
    // is no dedicated description.
    language_code string

}

// Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty. Returns
// True on success.
pub fn (ctx Context) set_my_description(params SetMyDescriptionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyDescription", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_description` function.
[params]
pub struct GetMyDescriptionParams {
pub mut:
    // A two-letter ISO 639-1 language code or an empty string
    language_code string

}

// Use this method to get the current bot description for the given user language. Returns BotDescription on success.
pub fn (ctx Context) get_my_description(params GetMyDescriptionParams) !BotDescription {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyDescription", body)!
    res := json.decode(ApiResponse[BotDescription], raw_json)!
    return res.result
}

// Params for the `set_my_short_description` function.
[params]
pub struct SetMyShortDescriptionParams {
pub mut:
    // New short description for the bot; 0-120 characters. Pass an empty string to remove the dedicated short description for
    // the given language.
    short_description string

    // A two-letter ISO 639-1 language code. If empty, the short description will be applied to all users for whose language
    // there is no dedicated short description.
    language_code string

}

// Use this method to change the bot's short description, which is shown on the bot's profile page and is sent together
// with the link when users share the bot. Returns True on success.
pub fn (ctx Context) set_my_short_description(params SetMyShortDescriptionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyShortDescription", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_short_description` function.
[params]
pub struct GetMyShortDescriptionParams {
pub mut:
    // A two-letter ISO 639-1 language code or an empty string
    language_code string

}

// Use this method to get the current bot short description for the given user language. Returns BotShortDescription on
// success.
pub fn (ctx Context) get_my_short_description(params GetMyShortDescriptionParams) !BotShortDescription {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyShortDescription", body)!
    res := json.decode(ApiResponse[BotShortDescription], raw_json)!
    return res.result
}

// Params for the `set_chat_menu_button` function.
[params]
pub struct SetChatMenuButtonParams {
pub mut:
    // Unique identifier for the target private chat. If not specified, default bot's menu button will be changed
    chat_id i64

    // A JSON-serialized object for the bot's new menu button. Defaults to MenuButtonDefault
    menu_button MenuButton

}

// Use this method to change the bot's menu button in a private chat, or the default menu button. Returns True on success.
pub fn (ctx Context) set_chat_menu_button(params SetChatMenuButtonParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setChatMenuButton", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_chat_menu_button` function.
[params]
pub struct GetChatMenuButtonParams {
pub mut:
    // Unique identifier for the target private chat. If not specified, default bot's menu button will be returned
    chat_id i64

}

// Use this method to get the current value of the bot's menu button in a private chat, or the default menu button.
// Returns MenuButton on success.
pub fn (ctx Context) get_chat_menu_button(params GetChatMenuButtonParams) !MenuButton {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getChatMenuButton", body)!
    res := json.decode(ApiResponse[MenuButton], raw_json)!
    return res.result
}

// Params for the `set_my_default_administrator_rights` function.
[params]
pub struct SetMyDefaultAdministratorRightsParams {
pub mut:
    // A JSON-serialized object describing new default administrator rights. If not specified, the default administrator
    // rights will be cleared.
    rights ChatAdministratorRights

    // Pass True to change the default administrator rights of the bot in channels. Otherwise, the default administrator
    // rights of the bot for groups and supergroups will be changed.
    for_channels bool

}

// Use this method to change the default administrator rights requested by the bot when it's added as an administrator to
// groups or channels. These rights will be suggested to users, but they are free to modify the list before adding the
// bot. Returns True on success.
pub fn (ctx Context) set_my_default_administrator_rights(params SetMyDefaultAdministratorRightsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setMyDefaultAdministratorRights", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `get_my_default_administrator_rights` function.
[params]
pub struct GetMyDefaultAdministratorRightsParams {
pub mut:
    // Pass True to get default administrator rights of the bot in channels. Otherwise, default administrator rights of the
    // bot for groups and supergroups will be returned.
    for_channels bool

}

// Use this method to get the current default administrator rights of the bot. Returns ChatAdministratorRights on success.
pub fn (ctx Context) get_my_default_administrator_rights(params GetMyDefaultAdministratorRightsParams) !ChatAdministratorRights {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getMyDefaultAdministratorRights", body)!
    res := json.decode(ApiResponse[ChatAdministratorRights], raw_json)!
    return res.result
}

// Params for the `edit_message_text` function.
[params]
pub struct EditMessageTextParams {
pub mut:
    // Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel
    // (in the format @channelusername)
    chat_id IntegerOrString

    // Required if inline_message_id is not specified. Identifier of the message to edit
    message_id i64

    // Required if chat_id and message_id are not specified. Identifier of the inline message
    inline_message_id string

    // New text of the message, 1-4096 characters after entities parsing
    text string [required]

    // Mode for parsing entities in the message text. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode
    entities []MessageEntity

    // Disables link previews for links in this message
    disable_web_page_preview bool

    // A JSON-serialized object for an inline keyboard.
    reply_markup InlineKeyboardMarkup

}

// Use this method to edit text and game messages. On success, if the edited message is not an inline message, the edited
// Message is returned, otherwise True is returned.
pub fn (ctx Context) edit_message_text(params EditMessageTextParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageText", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `edit_message_caption` function.
[params]
pub struct EditMessageCaptionParams {
pub mut:
    // Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel
    // (in the format @channelusername)
    chat_id IntegerOrString

    // Required if inline_message_id is not specified. Identifier of the message to edit
    message_id i64

    // Required if chat_id and message_id are not specified. Identifier of the inline message
    inline_message_id string

    // New caption of the message, 0-1024 characters after entities parsing
    caption string

    // Mode for parsing entities in the message caption. See formatting options for more details.
    parse_mode string

    // A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
    caption_entities []MessageEntity

    // A JSON-serialized object for an inline keyboard.
    reply_markup InlineKeyboardMarkup

}

// Use this method to edit captions of messages. On success, if the edited message is not an inline message, the edited
// Message is returned, otherwise True is returned.
pub fn (ctx Context) edit_message_caption(params EditMessageCaptionParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageCaption", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `edit_message_media` function.
[params]
pub struct EditMessageMediaParams {
pub mut:
    // Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel
    // (in the format @channelusername)
    chat_id IntegerOrString

    // Required if inline_message_id is not specified. Identifier of the message to edit
    message_id i64

    // Required if chat_id and message_id are not specified. Identifier of the inline message
    inline_message_id string

    // A JSON-serialized object for a new media content of the message
    media InputMedia [required]

    // A JSON-serialized object for a new inline keyboard.
    reply_markup InlineKeyboardMarkup

}

// Use this method to edit animation, audio, document, photo, or video messages. If a message is part of a message album,
// then it can be edited only to an audio for audio albums, only to a document for document albums and to a photo or a
// video otherwise. When an inline message is edited, a new file can't be uploaded; use a previously uploaded file via
// its file_id or specify a URL. On success, if the edited message is not an inline message, the edited Message is
// returned, otherwise True is returned.
pub fn (ctx Context) edit_message_media(params EditMessageMediaParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageMedia", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `edit_message_live_location` function.
[params]
pub struct EditMessageLiveLocationParams {
pub mut:
    // Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel
    // (in the format @channelusername)
    chat_id IntegerOrString

    // Required if inline_message_id is not specified. Identifier of the message to edit
    message_id i64

    // Required if chat_id and message_id are not specified. Identifier of the inline message
    inline_message_id string

    // Latitude of new location
    latitude f64 [required]

    // Longitude of new location
    longitude f64 [required]

    // The radius of uncertainty for the location, measured in meters; 0-1500
    horizontal_accuracy f64

    // Direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
    heading i64

    // The maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and
    // 100000 if specified.
    proximity_alert_radius i64

    // A JSON-serialized object for a new inline keyboard.
    reply_markup InlineKeyboardMarkup

}

// Use this method to edit live location messages. A location can be edited until its live_period expires or editing is
// explicitly disabled by a call to stopMessageLiveLocation. On success, if the edited message is not an inline
// message, the edited Message is returned, otherwise True is returned.
pub fn (ctx Context) edit_message_live_location(params EditMessageLiveLocationParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageLiveLocation", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `stop_message_live_location` function.
[params]
pub struct StopMessageLiveLocationParams {
pub mut:
    // Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel
    // (in the format @channelusername)
    chat_id IntegerOrString

    // Required if inline_message_id is not specified. Identifier of the message with live location to stop
    message_id i64

    // Required if chat_id and message_id are not specified. Identifier of the inline message
    inline_message_id string

    // A JSON-serialized object for a new inline keyboard.
    reply_markup InlineKeyboardMarkup

}

// Use this method to stop updating a live location message before live_period expires. On success, if the message is not
// an inline message, the edited Message is returned, otherwise True is returned.
pub fn (ctx Context) stop_message_live_location(params StopMessageLiveLocationParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("stopMessageLiveLocation", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `edit_message_reply_markup` function.
[params]
pub struct EditMessageReplyMarkupParams {
pub mut:
    // Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel
    // (in the format @channelusername)
    chat_id IntegerOrString

    // Required if inline_message_id is not specified. Identifier of the message to edit
    message_id i64

    // Required if chat_id and message_id are not specified. Identifier of the inline message
    inline_message_id string

    // A JSON-serialized object for an inline keyboard.
    reply_markup InlineKeyboardMarkup

}

// Use this method to edit only the reply markup of messages. On success, if the edited message is not an inline message,
// the edited Message is returned, otherwise True is returned.
pub fn (ctx Context) edit_message_reply_markup(params EditMessageReplyMarkupParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("editMessageReplyMarkup", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `stop_poll` function.
[params]
pub struct StopPollParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Identifier of the original message with the poll
    message_id i64 [required]

    // A JSON-serialized object for a new message inline keyboard.
    reply_markup InlineKeyboardMarkup

}

// Use this method to stop a poll which was sent by the bot. On success, the stopped Poll is returned.
pub fn (ctx Context) stop_poll(params StopPollParams) !Poll {
    mut body := json.encode(params)
    mut raw_json := ctx.request("stopPoll", body)!
    res := json.decode(ApiResponse[Poll], raw_json)!
    return res.result
}

// Params for the `delete_message` function.
[params]
pub struct DeleteMessageParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Identifier of the message to delete
    message_id i64 [required]

}

// Use this method to delete a message, including service messages, with the following limitations:
// - A message can only be deleted if it was sent less than 48 hours ago.
// - Service messages about a supergroup, channel, or forum topic creation can't be deleted.
// - A dice message in a private chat can only be deleted if it was sent more than 24 hours ago.
// - Bots can delete outgoing messages in private chats, groups, and supergroups.
// - Bots can delete incoming messages in private chats.
// - Bots granted can_post_messages permissions can delete outgoing messages in channels.
// - If the bot is an administrator of a group, it can delete any message there.
// - If the bot has can_delete_messages permission in a supergroup or a channel, it can delete any message there.
// Returns True on success.
pub fn (ctx Context) delete_message(params DeleteMessageParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteMessage", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `send_sticker` function.
[params]
pub struct SendStickerParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Sticker to send. Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an
    // HTTP URL as a String for Telegram to get a .WEBP sticker from the Internet, or upload a new .WEBP or .TGS sticker
    // using multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files.
    // Video stickers can only be sent by a file_id. Animated stickers can't be sent via an HTTP URL.
    sticker InputFileOrString [required]

    // Emoji associated with the sticker; only for just uploaded stickers
    emoji string

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to
    // remove reply keyboard or to force a reply from the user.
    reply_markup InlineKeyboardMarkupOrReplyKeyboardMarkupOrReplyKeyboardRemoveOrForceReply

}

// Use this method to send static .WEBP, animated .TGS, or video .WEBM stickers. On success, the sent Message is returned.
pub fn (ctx Context) send_sticker(params SendStickerParams) !Message {
    mut form := http.PostMultipartFormConfig{
        form: {
            "chat_id": json.encode(params.chat_id),
            "message_thread_id": params.message_thread_id.str(),
            "emoji": params.emoji,
            "disable_notification": params.disable_notification.str(),
            "protect_content": params.protect_content.str(),
            "reply_to_message_id": params.reply_to_message_id.str(),
            "allow_sending_without_reply": params.allow_sending_without_reply.str(),
            "reply_markup": json.encode(params.reply_markup),
        },
    }

    key := random_string(10)
    form.files[key] = []
    if params.sticker is InputFile {
        form.files[key] << http.FileData{
            filename: params.sticker.filename,
            content_type: params.sticker.content_type,
            data: params.sticker.data,
        }
    } else {
        form.form["sticker"] = params.sticker as string
    }

    mut raw_json := ctx.request_multipart("sendSticker", form)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `get_sticker_set` function.
[params]
pub struct GetStickerSetParams {
pub mut:
    // Name of the sticker set
    name string [required]

}

// Use this method to get a sticker set. On success, a StickerSet object is returned.
pub fn (ctx Context) get_sticker_set(params GetStickerSetParams) !StickerSet {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getStickerSet", body)!
    res := json.decode(ApiResponse[StickerSet], raw_json)!
    return res.result
}

// Params for the `get_custom_emoji_stickers` function.
[params]
pub struct GetCustomEmojiStickersParams {
pub mut:
    // List of custom emoji identifiers. At most 200 custom emoji identifiers can be specified.
    custom_emoji_ids []string [required]

}

// Use this method to get information about custom emoji stickers by their identifiers. Returns an Array of Sticker
// objects.
pub fn (ctx Context) get_custom_emoji_stickers(params GetCustomEmojiStickersParams) ![]Sticker {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getCustomEmojiStickers", body)!
    res := json.decode(ApiResponse[[]Sticker], raw_json)!
    return res.result
}

// Params for the `upload_sticker_file` function.
[params]
pub struct UploadStickerFileParams {
pub mut:
    // User identifier of sticker file owner
    user_id i64 [required]

    // A file with the sticker in .WEBP, .PNG, .TGS, or .WEBM format. See https://core.telegram.org/stickers for technical
    // requirements. More information on Sending Files: https://core.telegram.org/bots/api#sending-files
    sticker InputFile [required]

    // Format of the sticker, must be one of "static", "animated", "video"
    sticker_format string [required]

}

// Use this method to upload a file with a sticker for later use in the createNewStickerSet and addStickerToSet methods
// (the file can be used multiple times). Returns the uploaded File on success.
pub fn (ctx Context) upload_sticker_file(params UploadStickerFileParams) !File {
    mut form := http.PostMultipartFormConfig{
        form: {
            "user_id": params.user_id.str(),
            "sticker_format": params.sticker_format,
        },
    }

    key := random_string(10)
    form.files[key] = []
    form.files[key] << http.FileData{
        filename: params.sticker.filename,
        content_type: params.sticker.content_type,
        data: params.sticker.data,
    }

    mut raw_json := ctx.request_multipart("uploadStickerFile", form)!
    res := json.decode(ApiResponse[File], raw_json)!
    return res.result
}

// Params for the `create_new_sticker_set` function.
[params]
pub struct CreateNewStickerSetParams {
pub mut:
    // User identifier of created sticker set owner
    user_id i64 [required]

    // Short name of sticker set, to be used in t.me/addstickers/ URLs (e.g., animals). Can contain only English letters,
    // digits and underscores. Must begin with a letter, can't contain consecutive underscores and must end in
    // "_by_<bot_username>". <bot_username> is case insensitive. 1-64 characters.
    name string [required]

    // Sticker set title, 1-64 characters
    title string [required]

    // A JSON-serialized list of 1-50 initial stickers to be added to the sticker set
    stickers []InputSticker [required]

    // Format of stickers in the set, must be one of "static", "animated", "video"
    sticker_format string [required]

    // Type of stickers in the set, pass "regular", "mask", or "custom_emoji". By default, a regular sticker set is created.
    sticker_type string

    // Pass True if stickers in the sticker set must be repainted to the color of text when used in messages, the accent color
    // if used as emoji status, white on chat photos, or another appropriate color based on context; for custom emoji sticker
    // sets only
    needs_repainting bool

}

// Use this method to create a new sticker set owned by a user. The bot will be able to edit the sticker set thus created.
// Returns True on success.
pub fn (ctx Context) create_new_sticker_set(params CreateNewStickerSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("createNewStickerSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `add_sticker_to_set` function.
[params]
pub struct AddStickerToSetParams {
pub mut:
    // User identifier of sticker set owner
    user_id i64 [required]

    // Sticker set name
    name string [required]

    // A JSON-serialized object with information about the added sticker. If exactly the same sticker had already been added
    // to the set, then the set isn't changed.
    sticker InputSticker [required]

}

// Use this method to add a new sticker to a set created by the bot. The format of the added sticker must match the format
// of the other stickers in the set. Emoji sticker sets can have up to 200 stickers. Animated and video sticker sets can
// have up to 50 stickers. Static sticker sets can have up to 120 stickers. Returns True on success.
pub fn (ctx Context) add_sticker_to_set(params AddStickerToSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("addStickerToSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_position_in_set` function.
[params]
pub struct SetStickerPositionInSetParams {
pub mut:
    // File identifier of the sticker
    sticker string [required]

    // New sticker position in the set, zero-based
    position i64 [required]

}

// Use this method to move a sticker in a set created by the bot to a specific position. Returns True on success.
pub fn (ctx Context) set_sticker_position_in_set(params SetStickerPositionInSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerPositionInSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_sticker_from_set` function.
[params]
pub struct DeleteStickerFromSetParams {
pub mut:
    // File identifier of the sticker
    sticker string [required]

}

// Use this method to delete a sticker from a set created by the bot. Returns True on success.
pub fn (ctx Context) delete_sticker_from_set(params DeleteStickerFromSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteStickerFromSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_emoji_list` function.
[params]
pub struct SetStickerEmojiListParams {
pub mut:
    // File identifier of the sticker
    sticker string [required]

    // A JSON-serialized list of 1-20 emoji associated with the sticker
    emoji_list []string [required]

}

// Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The sticker must belong to a
// sticker set created by the bot. Returns True on success.
pub fn (ctx Context) set_sticker_emoji_list(params SetStickerEmojiListParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerEmojiList", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_keywords` function.
[params]
pub struct SetStickerKeywordsParams {
pub mut:
    // File identifier of the sticker
    sticker string [required]

    // A JSON-serialized list of 0-20 search keywords for the sticker with total length of up to 64 characters
    keywords []string

}

// Use this method to change search keywords assigned to a regular or custom emoji sticker. The sticker must belong to a
// sticker set created by the bot. Returns True on success.
pub fn (ctx Context) set_sticker_keywords(params SetStickerKeywordsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerKeywords", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_mask_position` function.
[params]
pub struct SetStickerMaskPositionParams {
pub mut:
    // File identifier of the sticker
    sticker string [required]

    // A JSON-serialized object with the position where the mask should be placed on faces. Omit the parameter to remove the
    // mask position.
    mask_position MaskPosition

}

// Use this method to change the mask position of a mask sticker. The sticker must belong to a sticker set that was
// created by the bot. Returns True on success.
pub fn (ctx Context) set_sticker_mask_position(params SetStickerMaskPositionParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerMaskPosition", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_set_title` function.
[params]
pub struct SetStickerSetTitleParams {
pub mut:
    // Sticker set name
    name string [required]

    // Sticker set title, 1-64 characters
    title string [required]

}

// Use this method to set the title of a created sticker set. Returns True on success.
pub fn (ctx Context) set_sticker_set_title(params SetStickerSetTitleParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setStickerSetTitle", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_sticker_set_thumbnail` function.
[params]
pub struct SetStickerSetThumbnailParams {
pub mut:
    // Sticker set name
    name string [required]

    // User identifier of the sticker set owner
    user_id i64 [required]

    // A .WEBP or .PNG image with the thumbnail, must be up to 128 kilobytes in size and have a width and height of exactly
    // 100px, or a .TGS animation with a thumbnail up to 32 kilobytes in size (see
    // https://core.telegram.org/stickers#animated-sticker-requirements for
    // animated sticker technical requirements), or a WEBM video with the
    // thumbnail up to 32 kilobytes in size; see
    // https://core.telegram.org/stickers#video-sticker-requirements
    // for video sticker technical requirements. Pass a file_id as a
    // String to send a file that already exists on the Telegram
    // servers, pass an HTTP URL as a String for Telegram to get
    // a file from the Internet, or upload a new one using
    // multipart/form-data. More information on Sending
    // Files:
    // https://core.telegram.org/bots/api#sending-files. Animated and video sticker set thumbnails can't be uploaded via HTTP
    // URL. If omitted, then the thumbnail is dropped and the first sticker is used as the thumbnail.
    thumbnail InputFileOrString

}

// Use this method to set the thumbnail of a regular or mask sticker set. The format of the thumbnail file must match the
// format of the stickers in the set. Returns True on success.
pub fn (ctx Context) set_sticker_set_thumbnail(params SetStickerSetThumbnailParams) !bool {
    mut form := http.PostMultipartFormConfig{
        form: {
            "name": params.name,
            "user_id": params.user_id.str(),
        },
    }

    key := random_string(10)
    form.files[key] = []
    if params.thumbnail is InputFile {
        form.files[key] << http.FileData{
            filename: params.thumbnail.filename,
            content_type: params.thumbnail.content_type,
            data: params.thumbnail.data,
        }
    } else {
        form.form["thumbnail"] = params.thumbnail as string
    }

    mut raw_json := ctx.request_multipart("setStickerSetThumbnail", form)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_custom_emoji_sticker_set_thumbnail` function.
[params]
pub struct SetCustomEmojiStickerSetThumbnailParams {
pub mut:
    // Sticker set name
    name string [required]

    // Custom emoji identifier of a sticker from the sticker set; pass an empty string to drop the thumbnail and use the first
    // sticker as the thumbnail.
    custom_emoji_id string

}

// Use this method to set the thumbnail of a custom emoji sticker set. Returns True on success.
pub fn (ctx Context) set_custom_emoji_sticker_set_thumbnail(params SetCustomEmojiStickerSetThumbnailParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setCustomEmojiStickerSetThumbnail", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `delete_sticker_set` function.
[params]
pub struct DeleteStickerSetParams {
pub mut:
    // Sticker set name
    name string [required]

}

// Use this method to delete a sticker set that was created by the bot. Returns True on success.
pub fn (ctx Context) delete_sticker_set(params DeleteStickerSetParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("deleteStickerSet", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `answer_inline_query` function.
[params]
pub struct AnswerInlineQueryParams {
pub mut:
    // Unique identifier for the answered query
    inline_query_id string [required]

    // A JSON-serialized array of results for the inline query
    results []InlineQueryResult [required]

    // The maximum amount of time in seconds that the result of the inline query may be cached on the server. Defaults to 300.
    cache_time i64

    // Pass True if results may be cached on the server side only for the user that sent the query. By default, results may be
    // returned to any user who sends the same query.
    is_personal bool

    // Pass the offset that a client should send in the next query with the same text to receive more results. Pass an empty
    // string if there are no more results or if you don't support pagination. Offset length can't exceed 64 bytes.
    next_offset string

    // A JSON-serialized object describing a button to be shown above inline query results
    button InlineQueryResultsButton

}

// Use this method to send answers to an inline query. On success, True is returned.
// No more than 50 results per query are allowed.
pub fn (ctx Context) answer_inline_query(params AnswerInlineQueryParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerInlineQuery", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `answer_web_app_query` function.
[params]
pub struct AnswerWebAppQueryParams {
pub mut:
    // Unique identifier for the query to be answered
    web_app_query_id string [required]

    // A JSON-serialized object describing the message to be sent
    result InlineQueryResult [required]

}

// Use this method to set the result of an interaction with a Web App and send a corresponding message on behalf of the
// user to the chat from which the query originated. On success, a SentWebAppMessage object is returned.
pub fn (ctx Context) answer_web_app_query(params AnswerWebAppQueryParams) !SentWebAppMessage {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerWebAppQuery", body)!
    res := json.decode(ApiResponse[SentWebAppMessage], raw_json)!
    return res.result
}

// Params for the `send_invoice` function.
[params]
pub struct SendInvoiceParams {
pub mut:
    // Unique identifier for the target chat or username of the target channel (in the format @channelusername)
    chat_id IntegerOrString [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Product name, 1-32 characters
    title string [required]

    // Product description, 1-255 characters
    description string [required]

    // Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.
    payload string [required]

    // Payment provider token, obtained via @BotFather
    provider_token string [required]

    // Three-letter ISO 4217 currency code, see more on currencies
    currency string [required]

    // Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax,
    // bonus, etc.)
    prices []LabeledPrice [required]

    // The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example,
    // for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the
    // number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0
    max_tip_amount i64

    // A JSON-serialized array of suggested amounts of tips in the smallest units of the currency (integer, not float/double).
    // At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly
    // increased order and must not exceed max_tip_amount.
    suggested_tip_amounts []i64

    // Unique deep-linking parameter. If left empty, forwarded copies of the sent message will have a Pay button, allowing
    // multiple users to pay directly from the forwarded message, using the same invoice. If non-empty, forwarded copies
    // of the sent message will have a URL button with a deep link to the bot (instead of a Pay button), with the value
    // used as the start parameter
    start_parameter string

    // JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of
    // required fields should be provided by the payment provider.
    provider_data string

    // URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like
    // it better when they see what they are paying for.
    photo_url string

    // Photo size in bytes
    photo_size i64

    // Photo width
    photo_width i64

    // Photo height
    photo_height i64

    // Pass True if you require the user's full name to complete the order
    need_name bool

    // Pass True if you require the user's phone number to complete the order
    need_phone_number bool

    // Pass True if you require the user's email address to complete the order
    need_email bool

    // Pass True if you require the user's shipping address to complete the order
    need_shipping_address bool

    // Pass True if the user's phone number should be sent to provider
    send_phone_number_to_provider bool

    // Pass True if the user's email address should be sent to provider
    send_email_to_provider bool

    // Pass True if the final price depends on the shipping method
    is_flexible bool

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // A JSON-serialized object for an inline keyboard. If empty, one 'Pay total price' button will be shown. If not empty,
    // the first button must be a Pay button.
    reply_markup InlineKeyboardMarkup

}

// Use this method to send invoices. On success, the sent Message is returned.
pub fn (ctx Context) send_invoice(params SendInvoiceParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendInvoice", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `create_invoice_link` function.
[params]
pub struct CreateInvoiceLinkParams {
pub mut:
    // Product name, 1-32 characters
    title string [required]

    // Product description, 1-255 characters
    description string [required]

    // Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.
    payload string [required]

    // Payment provider token, obtained via BotFather
    provider_token string [required]

    // Three-letter ISO 4217 currency code, see more on currencies
    currency string [required]

    // Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax,
    // bonus, etc.)
    prices []LabeledPrice [required]

    // The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example,
    // for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the
    // number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0
    max_tip_amount i64

    // A JSON-serialized array of suggested amounts of tips in the smallest units of the currency (integer, not float/double).
    // At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly
    // increased order and must not exceed max_tip_amount.
    suggested_tip_amounts []i64

    // JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of
    // required fields should be provided by the payment provider.
    provider_data string

    // URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service.
    photo_url string

    // Photo size in bytes
    photo_size i64

    // Photo width
    photo_width i64

    // Photo height
    photo_height i64

    // Pass True if you require the user's full name to complete the order
    need_name bool

    // Pass True if you require the user's phone number to complete the order
    need_phone_number bool

    // Pass True if you require the user's email address to complete the order
    need_email bool

    // Pass True if you require the user's shipping address to complete the order
    need_shipping_address bool

    // Pass True if the user's phone number should be sent to the provider
    send_phone_number_to_provider bool

    // Pass True if the user's email address should be sent to the provider
    send_email_to_provider bool

    // Pass True if the final price depends on the shipping method
    is_flexible bool

}

// Use this method to create a link for an invoice. Returns the created invoice link as String on success.
pub fn (ctx Context) create_invoice_link(params CreateInvoiceLinkParams) !string {
    mut body := json.encode(params)
    mut raw_json := ctx.request("createInvoiceLink", body)!
    res := json.decode(ApiResponse[string], raw_json)!
    return res.result
}

// Params for the `answer_shipping_query` function.
[params]
pub struct AnswerShippingQueryParams {
pub mut:
    // Unique identifier for the query to be answered
    shipping_query_id string [required]

    // Pass True if delivery to the specified address is possible and False if there are any problems (for example, if
    // delivery to the specified address is not possible)
    ok bool [required]

    // Required if ok is True. A JSON-serialized array of available shipping options.
    shipping_options []ShippingOption

    // Required if ok is False. Error message in human readable form that explains why it is impossible to complete the order
    // (e.g. "Sorry, delivery to your desired address is unavailable'). Telegram will display this message to the user.
    error_message string

}

// If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the Bot API will send
// an Update with a shipping_query field to the bot. Use this method to reply to shipping queries. On success, True is
// returned.
pub fn (ctx Context) answer_shipping_query(params AnswerShippingQueryParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerShippingQuery", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `answer_pre_checkout_query` function.
[params]
pub struct AnswerPreCheckoutQueryParams {
pub mut:
    // Unique identifier for the query to be answered
    pre_checkout_query_id string [required]

    // Specify True if everything is alright (goods are available, etc.) and the bot is ready to proceed with the order. Use
    // False if there are any problems.
    ok bool [required]

    // Required if ok is False. Error message in human readable form that explains the reason for failure to proceed with the
    // checkout (e.g. "Sorry, somebody just bought the last of our amazing black T-shirts while you were busy filling out
    // your payment details. Please choose a different color or garment!"). Telegram will display this message to the
    // user.
    error_message string

}

// Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of
// an Update with the field pre_checkout_query. Use this method to respond to such pre-checkout queries. On success, True
// is returned. Note: The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.
pub fn (ctx Context) answer_pre_checkout_query(params AnswerPreCheckoutQueryParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("answerPreCheckoutQuery", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `set_passport_data_errors` function.
[params]
pub struct SetPassportDataErrorsParams {
pub mut:
    // User identifier
    user_id i64 [required]

    // A JSON-serialized array describing the errors
    errors []PassportElementError [required]

}

// Informs a user that some of the Telegram Passport elements they provided contains errors. The user will not be able to
// re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error
// must change). Returns True on success.
// Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For
// example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering,
// etc. Supply some details in the error message to make sure the user knows how to correct the issues.
pub fn (ctx Context) set_passport_data_errors(params SetPassportDataErrorsParams) !bool {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setPassportDataErrors", body)!
    res := json.decode(ApiResponse[bool], raw_json)!
    return res.result
}

// Params for the `send_game` function.
[params]
pub struct SendGameParams {
pub mut:
    // Unique identifier for the target chat
    chat_id i64 [required]

    // Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
    message_thread_id i64

    // Short name of the game, serves as the unique identifier for the game. Set up your games via @BotFather.
    game_short_name string [required]

    // Sends the message silently. Users will receive a notification with no sound.
    disable_notification bool

    // Protects the contents of the sent message from forwarding and saving
    protect_content bool

    // If the message is a reply, ID of the original message
    reply_to_message_id i64

    // Pass True if the message should be sent even if the specified replied-to message is not found
    allow_sending_without_reply bool

    // A JSON-serialized object for an inline keyboard. If empty, one 'Play game_title' button will be shown. If not empty,
    // the first button must launch the game.
    reply_markup InlineKeyboardMarkup

}

// Use this method to send a game. On success, the sent Message is returned.
pub fn (ctx Context) send_game(params SendGameParams) !Message {
    mut body := json.encode(params)
    mut raw_json := ctx.request("sendGame", body)!
    res := json.decode(ApiResponse[Message], raw_json)!
    return res.result
}

// Params for the `set_game_score` function.
[params]
pub struct SetGameScoreParams {
pub mut:
    // User identifier
    user_id i64 [required]

    // New score, must be non-negative
    score i64 [required]

    // Pass True if the high score is allowed to decrease. This can be useful when fixing mistakes or banning cheaters
    force bool

    // Pass True if the game message should not be automatically edited to include the current scoreboard
    disable_edit_message bool

    // Required if inline_message_id is not specified. Unique identifier for the target chat
    chat_id i64

    // Required if inline_message_id is not specified. Identifier of the sent message
    message_id i64

    // Required if chat_id and message_id are not specified. Identifier of the inline message
    inline_message_id string

}

// Use this method to set the score of the specified user in a game message. On success, if the message is not an inline
// message, the Message is returned, otherwise True is returned. Returns an error, if the new score is not greater than
// the user's current score in the chat and force is False.
pub fn (ctx Context) set_game_score(params SetGameScoreParams) !MessageOrBoolean {
    mut body := json.encode(params)
    mut raw_json := ctx.request("setGameScore", body)!
    res := json.decode(ApiResponse[MessageOrBoolean], raw_json)!
    return res.result
}

// Params for the `get_game_high_scores` function.
[params]
pub struct GetGameHighScoresParams {
pub mut:
    // Target user id
    user_id i64 [required]

    // Required if inline_message_id is not specified. Unique identifier for the target chat
    chat_id i64

    // Required if inline_message_id is not specified. Identifier of the sent message
    message_id i64

    // Required if chat_id and message_id are not specified. Identifier of the inline message
    inline_message_id string

}

// Use this method to get data for high score tables. Will return the score of the specified user and several of their
// neighbors in a game. Returns an Array of GameHighScore objects.
pub fn (ctx Context) get_game_high_scores(params GetGameHighScoresParams) ![]GameHighScore {
    mut body := json.encode(params)
    mut raw_json := ctx.request("getGameHighScores", body)!
    res := json.decode(ApiResponse[[]GameHighScore], raw_json)!
    return res.result
}

